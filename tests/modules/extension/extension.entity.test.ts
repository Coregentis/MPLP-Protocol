/**
 * ExtensionÂÆû‰ΩìÂçïÂÖÉÊµãËØï
 *
 * @description Âü∫‰∫éÂÆûÈôÖÊé•Âè£ÁöÑExtensionEntityÊµãËØï
 * @version 1.0.0
 * @layer ÊµãËØïÂ±Ç - ÂçïÂÖÉÊµãËØï
 * @coverage ÁõÆÊ†áË¶ÜÁõñÁéá 95%+
 * @pattern ‰∏éContext„ÄÅPlan„ÄÅRole„ÄÅConfirmÊ®°Âùó‰ΩøÁî®IDENTICALÁöÑÊµãËØïÊ®°Âºè
 */

import { ExtensionEntity } from '../../../src/modules/extension/domain/entities/extension.entity';
import { ExtensionEntityData, ExtensionStatus, ExtensionType } from '../../../src/modules/extension/types';
import { UUID } from '../../../src/shared/types';

describe('ExtensionEntityÊµãËØï', () => {

  describe('ÊûÑÈÄ†ÂáΩÊï∞ÂíåÂü∫Êú¨Â±ûÊÄßÊµãËØï', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÂàõÂª∫ExtensionÂÆû‰ΩìÂπ∂ËÆæÁΩÆÊâÄÊúâÂ±ûÊÄß', () => {
      // üìã Arrange - Âü∫‰∫éÂÆûÈôÖExtensionEntityÊûÑÈÄ†ÂáΩÊï∞
      const extensionData: ExtensionEntityData = {
        extensionId: 'ext-test-001' as UUID,
        contextId: 'ctx-test-001' as UUID,
        name: 'test-extension',
        displayName: 'Test Extension',
        description: 'Test extension for unit testing',
        version: '1.0.0',
        extensionType: 'plugin' as ExtensionType,
        status: 'active' as ExtensionStatus,
        protocolVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        compatibility: {
          mplpVersion: '1.0.0',
          requiredModules: ['context', 'plan'],
          dependencies: [
            {
              name: 'test-dependency',
              version: '1.0.0',
              optional: false,
              reason: 'Required for testing'
            }
          ],
          conflicts: []
        },
        configuration: {
          schema: { type: 'object', properties: {} },
          currentConfig: { enabled: true },
          defaultConfig: { enabled: false },
          validationRules: []
        },
        extensionPoints: [
          {
            id: 'test-hook',
            name: 'Test Hook',
            type: 'hook',
            description: 'Test extension point',
            parameters: [
              {
                name: 'data',
                type: 'object',
                required: true,
                description: 'Test data parameter'
              }
            ],
            returnType: 'boolean',
            async: false,
            executionOrder: 1
          }
        ],
        apiExtensions: [
          {
            endpoint: '/api/test',
            method: 'GET',
            handler: 'testHandler',
            middleware: [],
            authentication: {
              required: false,
              schemes: [],
              permissions: []
            },
            rateLimit: {
              enabled: false,
              requestsPerMinute: 100,
              burstSize: 10,
              keyGenerator: 'ip'
            },
            validation: {
              strictMode: false
            },
            documentation: {
              summary: 'Test API endpoint',
              tags: ['test'],
              examples: []
            }
          }
        ],
        eventSubscriptions: [
          {
            eventPattern: 'test.*',
            handler: 'testEventHandler',
            filterConditions: [],
            deliveryGuarantee: 'at_least_once',
            deadLetterQueue: {
              enabled: false,
              maxRetries: 3,
              retentionPeriod: 86400
            },
            retryPolicy: {
              maxAttempts: 3,
              backoffStrategy: 'exponential',
              initialDelay: 1000,
              maxDelay: 30000,
              retryableErrors: ['TIMEOUT', 'CONNECTION_ERROR']
            },
            batchProcessing: {
              enabled: false,
              batchSize: 10,
              flushInterval: 5000
            }
          }
        ],
        lifecycle: {
          installDate: new Date().toISOString(),
          lastUpdate: new Date().toISOString(),
          activationCount: 1,
          errorCount: 0,
          performanceMetrics: {
            averageResponseTime: 50,
            throughput: 100,
            errorRate: 0,
            memoryUsage: 1024,
            cpuUsage: 5,
            lastMeasurement: new Date().toISOString()
          },
          healthCheck: {
            enabled: true,
            interval: 30000,
            timeout: 5000,
            healthyThreshold: 2,
            unhealthyThreshold: 3
          }
        },
        security: {
          sandboxEnabled: true,
          resourceLimits: {
            maxMemory: 100 * 1024 * 1024,
            maxCpu: 50,
            maxFileSize: 10 * 1024 * 1024,
            maxNetworkConnections: 10,
            allowedDomains: [],
            blockedDomains: []
          },
          codeSigning: {
            required: false,
            trustedSigners: []
          },
          permissions: {
            fileSystem: { read: [], write: [], execute: [] },
            network: { allowedHosts: [], allowedPorts: [], protocols: [] },
            database: { read: [], write: [], admin: [] },
            api: { endpoints: [], methods: [], rateLimit: 100 }
          }
        },
        metadata: {
          author: {
            name: 'Test Author'
          },
          license: {
            type: 'MIT'
          },
          keywords: ['test', 'extension'],
          category: 'testing',
          screenshots: []
        },
        auditTrail: {
          events: [],
          complianceSettings: {
            retentionPeriod: 365,
            encryptionRequired: false,
            auditLevel: 'standard'
          }
        },
        performanceMetrics: {
          activationLatency: 100,
          executionTime: 50,
          memoryFootprint: 1024,
          cpuUtilization: 5,
          networkLatency: 10,
          errorRate: 0,
          throughput: 100,
          availability: 99.9,
          efficiencyScore: 95,
          healthStatus: 'healthy',
          alerts: []
        },
        monitoringIntegration: {
          providers: ['prometheus'],
          endpoints: [],
          dashboards: [],
          alerting: {
            enabled: true,
            channels: ['email'],
            thresholds: {
              errorRate: 5,
              responseTime: 1000,
              availability: 95
            }
          }
        },
        versionHistory: {
          versions: [],
          autoVersioning: {
            enabled: false,
            strategy: 'semantic',
            triggers: ['api_change', 'breaking_change']
          }
        },
        searchMetadata: {
          indexedFields: ['name', 'description', 'keywords'],
          searchStrategies: [],
          facets: []
        },
        eventIntegration: {
          eventBus: {
            provider: 'internal',
            connectionString: '',
            topics: []
          },
          eventRouting: {
            rules: [],
            defaultRoute: 'default'
          },
          eventTransformation: {
            enabled: false,
            rules: []
          }
        }
      };

      // üé¨ Act - ÂàõÂª∫ExtensionÂÆû‰Ωì
      const extension = new ExtensionEntity(extensionData);

      // ‚úÖ Assert - È™åËØÅÊâÄÊúâÂ±ûÊÄßÊ≠£Á°ÆËÆæÁΩÆ
      expect(extension.extensionId).toBe(extensionData.extensionId);
      expect(extension.contextId).toBe(extensionData.contextId);
      expect(extension.name).toBe(extensionData.name);
      expect(extension.displayName).toBe(extensionData.displayName);
      expect(extension.description).toBe(extensionData.description);
      expect(extension.version).toBe(extensionData.version);
      expect(extension.extensionType).toBe(extensionData.extensionType);
      expect(extension.status).toBe(extensionData.status);
      expect(extension.protocolVersion).toBe(extensionData.protocolVersion);
      expect(extension.compatibility).toEqual(extensionData.compatibility);
      expect(extension.configuration).toEqual(extensionData.configuration);
      expect(extension.extensionPoints).toEqual(extensionData.extensionPoints);
      expect(extension.apiExtensions).toEqual(extensionData.apiExtensions);
      expect(extension.eventSubscriptions).toEqual(extensionData.eventSubscriptions);
      expect(extension.lifecycle).toEqual(extensionData.lifecycle);
      expect(extension.security).toEqual(extensionData.security);
      expect(extension.metadata).toEqual(extensionData.metadata);
    });

    it('Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÊúÄÂ∞èÂåñÁöÑExtensionÊï∞ÊçÆ', () => {
      // üìã Arrange - ÊúÄÂ∞èÂåñÁöÑExtensionÊï∞ÊçÆ
      const minimalData: ExtensionEntityData = {
        extensionId: 'ext-minimal-001' as UUID,
        contextId: 'ctx-minimal-001' as UUID,
        name: 'minimal-extension',
        displayName: 'Minimal Extension',
        version: '1.0.0',
        extensionType: 'adapter' as ExtensionType,
        status: 'inactive' as ExtensionStatus,
        protocolVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        compatibility: {
          mplpVersion: '1.0.0',
          requiredModules: [],
          dependencies: [],
          conflicts: []
        },
        configuration: {
          schema: {},
          currentConfig: {},
          defaultConfig: {},
          validationRules: []
        },
        extensionPoints: [],
        apiExtensions: [],
        eventSubscriptions: [],
        lifecycle: {
          installDate: new Date().toISOString(),
          lastUpdate: new Date().toISOString(),
          activationCount: 0,
          errorCount: 0,
          performanceMetrics: {
            averageResponseTime: 0,
            throughput: 0,
            errorRate: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            lastMeasurement: new Date().toISOString()
          },
          healthCheck: {
            enabled: false,
            interval: 30000,
            timeout: 5000,
            healthyThreshold: 2,
            unhealthyThreshold: 3
          }
        },
        security: {
          sandboxEnabled: false,
          resourceLimits: {
            maxMemory: 0,
            maxCpu: 0,
            maxFileSize: 0,
            maxNetworkConnections: 0,
            allowedDomains: [],
            blockedDomains: []
          },
          codeSigning: {
            required: false,
            trustedSigners: []
          },
          permissions: {
            fileSystem: { read: [], write: [], execute: [] },
            network: { allowedHosts: [], allowedPorts: [], protocols: [] },
            database: { read: [], write: [], admin: [] },
            api: { endpoints: [], methods: [], rateLimit: 0 }
          }
        },
        metadata: {
          author: { name: '' },
          license: { type: '' },
          keywords: [],
          category: '',
          screenshots: []
        },
        auditTrail: {
          events: [],
          complianceSettings: {
            retentionPeriod: 0,
            encryptionRequired: false,
            auditLevel: 'none'
          }
        },
        performanceMetrics: {
          activationLatency: 0,
          executionTime: 0,
          memoryFootprint: 0,
          cpuUtilization: 0,
          networkLatency: 0,
          errorRate: 0,
          throughput: 0,
          availability: 0,
          efficiencyScore: 0,
          healthStatus: 'unhealthy',
          alerts: []
        },
        monitoringIntegration: {
          providers: [],
          endpoints: [],
          dashboards: [],
          alerting: {
            enabled: false,
            channels: [],
            thresholds: {
              errorRate: 0,
              responseTime: 0,
              availability: 0
            }
          }
        },
        versionHistory: {
          versions: [],
          autoVersioning: {
            enabled: false,
            strategy: 'manual',
            triggers: []
          }
        },
        searchMetadata: {
          indexedFields: [],
          searchStrategies: [],
          facets: []
        },
        eventIntegration: {
          eventBus: {
            provider: 'none',
            connectionString: '',
            topics: []
          },
          eventRouting: {
            rules: [],
            defaultRoute: ''
          },
          eventTransformation: {
            enabled: false,
            rules: []
          }
        }
      };

      // üé¨ Act - ÂàõÂª∫ÊúÄÂ∞èÂåñExtensionÂÆû‰Ωì
      const extension = new ExtensionEntity(minimalData);

      // ‚úÖ Assert - È™åËØÅÂü∫Êú¨Â±ûÊÄßÊ≠£Á°ÆËÆæÁΩÆ
      expect(extension.extensionId).toBe(minimalData.extensionId);
      expect(extension.name).toBe(minimalData.name);
      expect(extension.extensionType).toBe('adapter');
      expect(extension.status).toBe('inactive');
      expect(extension.extensionPoints).toHaveLength(0);
      expect(extension.apiExtensions).toHaveLength(0);
      expect(extension.eventSubscriptions).toHaveLength(0);
    });
  });

  describe('Áä∂ÊÄÅÁÆ°ÁêÜÊµãËØï', () => {
    let extension: ExtensionEntity;

    beforeEach(() => {
      const extensionData: ExtensionEntityData = {
        extensionId: 'ext-status-001' as UUID,
        contextId: 'ctx-status-001' as UUID,
        name: 'status-test-extension',
        displayName: 'Status Test Extension',
        version: '1.0.0',
        extensionType: 'plugin' as ExtensionType,
        status: 'inactive' as ExtensionStatus,
        protocolVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        // ... ÂÖ∂‰ªñÂøÖÈúÄÂ±ûÊÄßÁöÑÊúÄÂ∞èÂåñÁâàÊú¨
        compatibility: { mplpVersion: '1.0.0', requiredModules: [], dependencies: [], conflicts: [] },
        configuration: { schema: {}, currentConfig: {}, defaultConfig: {}, validationRules: [] },
        extensionPoints: [],
        apiExtensions: [],
        eventSubscriptions: [],
        lifecycle: {
          installDate: new Date().toISOString(),
          lastUpdate: new Date().toISOString(),
          activationCount: 0,
          errorCount: 0,
          performanceMetrics: {
            averageResponseTime: 0, throughput: 0, errorRate: 0, memoryUsage: 0, cpuUsage: 0, lastMeasurement: new Date().toISOString()
          },
          healthCheck: { enabled: false, interval: 30000, timeout: 5000, healthyThreshold: 2, unhealthyThreshold: 3 }
        },
        security: {
          sandboxEnabled: false,
          resourceLimits: { maxMemory: 0, maxCpu: 0, maxFileSize: 0, maxNetworkConnections: 0, allowedDomains: [], blockedDomains: [] },
          codeSigning: { required: false, trustedSigners: [] },
          permissions: {
            fileSystem: { read: [], write: [], execute: [] },
            network: { allowedHosts: [], allowedPorts: [], protocols: [] },
            database: { read: [], write: [], admin: [] },
            api: { endpoints: [], methods: [], rateLimit: 0 }
          }
        },
        metadata: { author: { name: '' }, license: { type: '' }, keywords: [], category: '', screenshots: [] },
        auditTrail: { events: [], complianceSettings: { retentionPeriod: 0, encryptionRequired: false, auditLevel: 'none' } },
        performanceMetrics: {
          activationLatency: 0, executionTime: 0, memoryFootprint: 0, cpuUtilization: 0, networkLatency: 0,
          errorRate: 0, throughput: 0, availability: 0, efficiencyScore: 0, healthStatus: 'unhealthy', alerts: []
        },
        monitoringIntegration: {
          providers: [], endpoints: [], dashboards: [],
          alerting: { enabled: false, channels: [], thresholds: { errorRate: 0, responseTime: 0, availability: 0 } }
        },
        versionHistory: { versions: [], autoVersioning: { enabled: false, strategy: 'manual', triggers: [] } },
        searchMetadata: { indexedFields: [], searchStrategies: [], facets: [] },
        eventIntegration: {
          eventBus: { provider: 'none', connectionString: '', topics: [] },
          eventRouting: { rules: [], defaultRoute: '' },
          eventTransformation: { enabled: false, rules: [] }
        }
      };

      extension = new ExtensionEntity(extensionData);
    });

    it('Â∫îËØ•ËÉΩÂ§üÊøÄÊ¥ªÊâ©Â±ï', () => {
      // üìã Arrange - Êâ©Â±ïÂàùÂßãÁä∂ÊÄÅ‰∏∫INACTIVE
      expect(extension.status).toBe('inactive');

      // üé¨ Act - ÊøÄÊ¥ªÊâ©Â±ï
      extension.activate();

      // ‚úÖ Assert - È™åËØÅÁä∂ÊÄÅÂèò‰∏∫ACTIVE
      expect(extension.status).toBe('active');
    });

    it('Â∫îËØ•ËÉΩÂ§üÂÅúÁî®Êâ©Â±ï', () => {
      // üìã Arrange - ÂÖàÊøÄÊ¥ªÊâ©Â±ï
      extension.activate();
      expect(extension.status).toBe('active');

      // üé¨ Act - ÂÅúÁî®Êâ©Â±ï
      extension.deactivate();

      // ‚úÖ Assert - È™åËØÅÁä∂ÊÄÅÂèò‰∏∫INACTIVE
      expect(extension.status).toBe('inactive');
    });

    it('Â∫îËØ•ËÉΩÂ§üÊ†áËÆ∞Êâ©Â±ï‰∏∫ÈîôËØØÁä∂ÊÄÅ', () => {
      // üìã Arrange - Êâ©Â±ïÂàùÂßãÁä∂ÊÄÅ
      const initialStatus = extension.status;

      // üé¨ Act - Ê†áËÆ∞‰∏∫ÈîôËØØÁä∂ÊÄÅ
      extension.markAsError();

      // ‚úÖ Assert - È™åËØÅÁä∂ÊÄÅÂèò‰∏∫ERROR
      expect(extension.status).toBe('error');
      expect(extension.status).not.toBe(initialStatus);
    });
  });

  describe('È™åËØÅÊñπÊ≥ïÊµãËØï', () => {
    it('Â∫îËØ•È™åËØÅÊâ©Â±ïÈÖçÁΩÆÁöÑÊúâÊïàÊÄß', () => {
      // üìã Arrange - ÂàõÂª∫ÊúâÊïàÈÖçÁΩÆÁöÑÊâ©Â±ï
      const validExtensionData: ExtensionEntityData = {
        extensionId: 'ext-valid-001' as UUID,
        contextId: 'ctx-valid-001' as UUID,
        name: 'valid-extension',
        displayName: 'Valid Extension',
        version: '1.0.0',
        extensionType: 'plugin' as ExtensionType,
        status: 'active' as ExtensionStatus,
        protocolVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        // ... ÂÖ∂‰ªñÂøÖÈúÄÂ±ûÊÄß
        compatibility: { mplpVersion: '1.0.0', requiredModules: [], dependencies: [], conflicts: [] },
        configuration: { schema: {}, currentConfig: {}, defaultConfig: {}, validationRules: [] },
        extensionPoints: [],
        apiExtensions: [],
        eventSubscriptions: [],
        lifecycle: {
          installDate: new Date().toISOString(),
          lastUpdate: new Date().toISOString(),
          activationCount: 0,
          errorCount: 0,
          performanceMetrics: {
            averageResponseTime: 0, throughput: 0, errorRate: 0, memoryUsage: 0, cpuUsage: 0, lastMeasurement: new Date().toISOString()
          },
          healthCheck: { enabled: false, interval: 30000, timeout: 5000, healthyThreshold: 2, unhealthyThreshold: 3 }
        },
        security: {
          sandboxEnabled: false,
          resourceLimits: { maxMemory: 0, maxCpu: 0, maxFileSize: 0, maxNetworkConnections: 0, allowedDomains: [], blockedDomains: [] },
          codeSigning: { required: false, trustedSigners: [] },
          permissions: {
            fileSystem: { read: [], write: [], execute: [] },
            network: { allowedHosts: [], allowedPorts: [], protocols: [] },
            database: { read: [], write: [], admin: [] },
            api: { endpoints: [], methods: [], rateLimit: 0 }
          }
        },
        metadata: { author: { name: '' }, license: { type: '' }, keywords: [], category: '', screenshots: [] },
        auditTrail: { events: [], complianceSettings: { retentionPeriod: 0, encryptionRequired: false, auditLevel: 'none' } },
        performanceMetrics: {
          activationLatency: 0, executionTime: 0, memoryFootprint: 0, cpuUtilization: 0, networkLatency: 0,
          errorRate: 0, throughput: 0, availability: 0, efficiencyScore: 0, healthStatus: 'healthy', alerts: []
        },
        monitoringIntegration: {
          providers: [], endpoints: [], dashboards: [],
          alerting: { enabled: false, channels: [], thresholds: { errorRate: 0, responseTime: 0, availability: 0 } }
        },
        versionHistory: { versions: [], autoVersioning: { enabled: false, strategy: 'manual', triggers: [] } },
        searchMetadata: { indexedFields: [], searchStrategies: [], facets: [] },
        eventIntegration: {
          eventBus: { provider: 'none', connectionString: '', topics: [] },
          eventRouting: { rules: [], defaultRoute: '' },
          eventTransformation: { enabled: false, rules: [] }
        }
      };

      const extension = new ExtensionEntity(validExtensionData);

      // üé¨ Act - È™åËØÅÊâ©Â±ï
      const isValid = extension.validate();

      // ‚úÖ Assert - È™åËØÅÁªìÊûú‰∏∫true
      expect(isValid).toBe(true);
    });
  });

  describe('ÊÄßËÉΩÊåáÊ†áÊµãËØï', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊõ¥Êñ∞ÊÄßËÉΩÊåáÊ†á', () => {
      // üìã Arrange - ÂàõÂª∫Êâ©Â±ïÂÆû‰Ωì
      const extensionData: ExtensionEntityData = {
        extensionId: 'ext-perf-001' as UUID,
        contextId: 'ctx-perf-001' as UUID,
        name: 'performance-extension',
        displayName: 'Performance Extension',
        version: '1.0.0',
        extensionType: 'plugin' as ExtensionType,
        status: 'active' as ExtensionStatus,
        protocolVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        // ... ÂÖ∂‰ªñÂøÖÈúÄÂ±ûÊÄßÁöÑÊúÄÂ∞èÂåñÁâàÊú¨
        compatibility: { mplpVersion: '1.0.0', requiredModules: [], dependencies: [], conflicts: [] },
        configuration: { schema: {}, currentConfig: {}, defaultConfig: {}, validationRules: [] },
        extensionPoints: [],
        apiExtensions: [],
        eventSubscriptions: [],
        lifecycle: {
          installDate: new Date().toISOString(),
          lastUpdate: new Date().toISOString(),
          activationCount: 0,
          errorCount: 0,
          performanceMetrics: {
            averageResponseTime: 100, throughput: 50, errorRate: 0, memoryUsage: 1024, cpuUsage: 10, lastMeasurement: new Date().toISOString()
          },
          healthCheck: { enabled: true, interval: 30000, timeout: 5000, healthyThreshold: 2, unhealthyThreshold: 3 }
        },
        security: {
          sandboxEnabled: true,
          resourceLimits: { maxMemory: 1024, maxCpu: 50, maxFileSize: 1024, maxNetworkConnections: 10, allowedDomains: [], blockedDomains: [] },
          codeSigning: { required: false, trustedSigners: [] },
          permissions: {
            fileSystem: { read: [], write: [], execute: [] },
            network: { allowedHosts: [], allowedPorts: [], protocols: [] },
            database: { read: [], write: [], admin: [] },
            api: { endpoints: [], methods: [], rateLimit: 100 }
          }
        },
        metadata: { author: { name: 'Test' }, license: { type: 'MIT' }, keywords: ['test'], category: 'test', screenshots: [] },
        auditTrail: { events: [], complianceSettings: { retentionPeriod: 365, encryptionRequired: false, auditLevel: 'standard' } },
        performanceMetrics: {
          activationLatency: 100, executionTime: 50, memoryFootprint: 1024, cpuUtilization: 10, networkLatency: 20,
          errorRate: 0, throughput: 50, availability: 99.9, efficiencyScore: 95, healthStatus: 'healthy', alerts: []
        },
        monitoringIntegration: {
          providers: ['prometheus'], endpoints: [], dashboards: [],
          alerting: { enabled: true, channels: ['email'], thresholds: { errorRate: 5, responseTime: 1000, availability: 95 } }
        },
        versionHistory: { versions: [], autoVersioning: { enabled: false, strategy: 'semantic', triggers: [] } },
        searchMetadata: { indexedFields: ['name'], searchStrategies: [], facets: [] },
        eventIntegration: {
          eventBus: { provider: 'internal', connectionString: '', topics: [] },
          eventRouting: { rules: [], defaultRoute: 'default' },
          eventTransformation: { enabled: false, rules: [] }
        }
      };

      const extension = new ExtensionEntity(extensionData);

      // üé¨ Act - Êõ¥Êñ∞ÊÄßËÉΩÊåáÊ†á
      const newMetrics = {
        averageResponseTime: 80,
        throughput: 75,
        errorRate: 0.1,
        memoryUsage: 1200,
        cpuUsage: 15,
        lastMeasurement: new Date().toISOString()
      };
      extension.updatePerformanceMetrics(newMetrics);

      // ‚úÖ Assert - È™åËØÅÊÄßËÉΩÊåáÊ†áÂ∑≤Êõ¥Êñ∞
      expect(extension.lifecycle.performanceMetrics.averageResponseTime).toBe(80);
      expect(extension.lifecycle.performanceMetrics.throughput).toBe(75);
      expect(extension.lifecycle.performanceMetrics.errorRate).toBe(0.1);
      expect(extension.lifecycle.performanceMetrics.memoryUsage).toBe(1200);
      expect(extension.lifecycle.performanceMetrics.cpuUsage).toBe(15);
    });
  });
});
