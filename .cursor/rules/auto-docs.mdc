description: "MPLP项目自动文档生成标准，包含JSDoc注释规范、API文档生成和代码注释要求"
globs: ["**/*.ts", "**/*.js", "**/*.md", "**/docs/**/*", "**/*.json"]
alwaysApply: true
---

# MPLP 自动文档规则

> **文件类型**: Agent Requested  
> **适用范围**: 所有自动文档生成和代码注释  
> **最后更新**: 2025-07-10

## 📚 自动文档生成策略

### 文档生成层次
```
📄 API文档 (OpenAPI/Swagger)
📄 代码文档 (JSDoc → HTML)
📄 架构文档 (代码 → 图表)
📄 用户文档 (Markdown → 网站)
📄 协议文档 (Schema → 规范)
```

### 触发机制
- **代码提交**: 自动生成JSDoc文档
- **API变更**: 自动更新OpenAPI规范
- **Schema更新**: 自动生成协议文档
- **定期任务**: 每日更新完整文档集

## 🎯 JSDoc 代码注释规范

### 函数注释模板
```typescript
/**
 * 创建新的MPLP上下文
 * 
 * 此函数负责创建一个新的项目上下文，包含初始状态设置、权限配置和生命周期管理。
 * 创建的上下文将被持久化到数据库，并返回完整的上下文协议对象。
 * 
 * @param {CreateContextRequest} data - 上下文创建参数
 * @param {string} data.name - 上下文名称，长度1-255字符
 * @param {object} [data.initialState] - 初始共享状态对象
 * @param {PermissionConfig} [data.permissions] - 权限配置
 * @param {string} [data.description] - 上下文描述
 * 
 * @returns {Promise<ContextProtocol>} Promise，解析为创建的上下文协议对象
 * 
 * @throws {ValidationError} 当输入数据验证失败时抛出
 * @throws {DatabaseError} 当数据库操作失败时抛出
 * @throws {PermissionError} 当权限检查失败时抛出
 * 
 * @example
 * ```typescript
 * // 创建基础上下文
 * const context = await createContext({
 *   name: 'My Project Context',
 *   description: 'Development context for my project'
 * });
 * 
 * // 创建带初始状态的上下文
 * const contextWithState = await createContext({
 *   name: 'Stateful Context',
 *   initialState: {
 *     environment: 'development',
 *     debug: true,
 *     features: ['feature-a', 'feature-b']
 *   },
 *   permissions: {
 *     read: ['developer', 'admin'],
 *     write: ['admin']
 *   }
 * });
 * ```
 * 
 * @see {@link ContextProtocol} 上下文协议定义
 * @see {@link updateContext} 更新上下文方法
 * @see {@link deleteContext} 删除上下文方法
 * 
 * @since 1.0.0
 * @version 1.0.0
 * @author MPLP团队
 */
export async function createContext(
  data: CreateContextRequest
): Promise<ContextProtocol> {
  // 实现逻辑...
}
```

### 类和接口注释
```typescript
/**
 * MPLP上下文服务
 * 
 * 提供上下文生命周期管理的完整功能，包括创建、更新、删除和查询操作。
 * 支持权限控制、状态管理和审计日志记录。
 * 
 * @class ContextService
 * @implements {IContextService}
 * 
 * @example
 * ```typescript
 * const contextService = new ContextService(repository, validator);
 * const context = await contextService.createContext({
 *   name: 'Example Context'
 * });
 * ```
 * 
 * @since 1.0.0
 */
export class ContextService implements IContextService {
  /**
   * 上下文数据仓库实例
   * @private
   * @readonly
   */
  private readonly repository: IContextRepository;

  /**
   * 数据验证器实例
   * @private
   * @readonly
   */
  private readonly validator: IValidator;

  /**
   * 创建ContextService实例
   * 
   * @param {IContextRepository} repository - 上下文数据仓库
   * @param {IValidator} validator - 数据验证器
   */
  constructor(
    repository: IContextRepository,
    validator: IValidator
  ) {
    this.repository = repository;
    this.validator = validator;
  }
}

/**
 * MPLP上下文协议接口
 * 
 * 定义上下文在MPLP系统中的标准结构和必需字段。
 * 所有上下文实例都必须遵循此协议规范。
 * 
 * @interface ContextProtocol
 * @extends {BaseProtocol}
 * 
 * @example
 * ```typescript
 * const context: ContextProtocol = {
 *   context_id: '123e4567-e89b-12d3-a456-426614174000',
 *   version: '1.0.0',
 *   timestamp: '2024-07-09T14:30:00Z',
 *   status: 'active',
 *   lifecycle_stage: 'planning',
 *   name: 'Example Context',
 *   shared_state: {}
 * };
 * ```
 */
export interface ContextProtocol extends BaseProtocol {
  /** 上下文唯一标识符 (UUID v4) */
  context_id: string;
  
  /** 当前状态: active | suspended | terminated */
  status: ContextStatus;
  
  /** 生命周期阶段: planning | executing | monitoring | completed */
  lifecycle_stage: LifecycleStage;
  
  /** 上下文名称 (1-255字符) */
  name: string;
  
  /** 共享状态数据，所有模块都可访问 */
  shared_state: Record<string, unknown>;
  
  /** 可选的上下文描述 */
  description?: string;
}
```

### 枚举和常量注释
```typescript
/**
 * MPLP上下文状态枚举
 * 
 * 定义上下文在其生命周期中可能的所有状态。
 * 状态转换必须遵循预定义的状态机规则。
 * 
 * @enum {string}
 * @readonly
 * 
 * @example
 * ```typescript
 * // 检查上下文状态
 * if (context.status === ContextStatus.ACTIVE) {
 *   console.log('Context is ready for operations');
 * }
 * ```
 */
export enum ContextStatus {
  /** 活跃状态 - 可以正常使用 */
  ACTIVE = 'active',
  
  /** 暂停状态 - 暂时不可用，可以恢复 */
  SUSPENDED = 'suspended',
  
  /** 终止状态 - 永久不可用，不可恢复 */
  TERMINATED = 'terminated'
}

/**
 * MPLP协议版本常量
 * 
 * 定义当前支持的协议版本号，遵循语义化版本规范。
 * 
 * @constant {string}
 * @default '1.0.0'
 * 
 * @example
 * ```typescript
 * const protocol = {
 *   version: PROTOCOL_VERSION,
 *   // ... other fields
 * };
 * ```
 */
export const PROTOCOL_VERSION = '1.0.0' as const;

/**
 * 默认配置常量
 * 
 * @namespace DefaultConfig
 */
export const DefaultConfig = {
  /** 默认超时时间 (毫秒) */
  TIMEOUT_MS: 30000,
  
  /** 最大重试次数 */
  MAX_RETRY_ATTEMPTS: 3,
  
  /** 默认上下文状态 */
  DEFAULT_STATUS: ContextStatus.ACTIVE
} as const;
```

## 🔧 自动文档工具配置

### JSDoc 配置
```javascript
// jsdoc.config.js
module.exports = {
  source: {
    include: ['./src/'],
    includePattern: '\\.(ts|js)$',
    exclude: ['node_modules/', 'dist/', '**/*.test.ts']
  },
  opts: {
    destination: './docs/api/',
    recurse: true
  },
  plugins: [
    'plugins/markdown',
    'plugins/typescript'
  ],
  templates: {
    cleverLinks: false,
    monospaceLinks: false
  },
  tags: {
    allowUnknownTags: true,
    dictionaries: ['jsdoc', 'closure']
  },
  typescript: {
    moduleRoot: './src'
  }
};
```

### TypeDoc 配置
```json
{
  "entryPoints": ["src/index.ts"],
  "out": "docs/typedoc",
  "theme": "default",
  "includeVersion": true,
  "excludePrivate": false,
  "excludeProtected": false,
  "excludeExternals": true,
  "readme": "README.md",
  "name": "MPLP API Documentation",
  "tsconfig": "tsconfig.json",
  "gaID": "UA-XXXXXXXX-X"
}
```

## 📄 OpenAPI 文档生成

### 新增API文档 (v1.0.1)
- **failure_resolver API**: 故障解决器API文档 (`docs/api/failure-resolver.md`)
  - Plan模块故障处理机制
  - TracePilot Enhanced Adapter集成
  - AI驱动的故障诊断和修复建议

### Swagger注解示例
```typescript
/**
 * @swagger
 * /api/v1/contexts:
 *   post:
 *     summary: 创建新的上下文
 *     description: 在MPLP系统中创建一个新的项目上下文
 *     tags:
 *       - Context
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateContextRequest'
 *           examples:
 *             basic:
 *               summary: 基础上下文创建
 *               value:
 *                 name: "My Project Context"
 *                 description: "Development context for my project"
 *             advanced:
 *               summary: 带初始状态的上下文
 *               value:
 *                 name: "Stateful Context"
 *                 initialState:
 *                   environment: "development"
 *                   debug: true
 *                 permissions:
 *                   read: ["developer", "admin"]
 *                   write: ["admin"]
 *     responses:
 *       201:
 *         description: 上下文创建成功
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ContextProtocol'
 *       400:
 *         description: 请求参数验证失败
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       500:
 *         description: 服务器内部错误
 *     security:
 *       - bearerAuth: []
 */
@Post('/contexts')
public async createContext(
  @Body() data: CreateContextRequest
): Promise<ContextProtocol> {
  return await this.contextService.createContext(data);
}
```

### Schema组件定义
```typescript
/**
 * @swagger
 * components:
 *   schemas:
 *     ContextProtocol:
 *       type: object
 *       required:
 *         - context_id
 *         - version
 *         - timestamp
 *         - status
 *         - lifecycle_stage
 *         - name
 *       properties:
 *         context_id:
 *           type: string
 *           format: uuid
 *           description: 上下文唯一标识符
 *           example: "123e4567-e89b-12d3-a456-426614174000"
 *         version:
 *           type: string
 *           pattern: '^\\d+\\.\\d+\\.\\d+$'
 *           description: 协议版本号
 *           example: "1.0.0"
 *         timestamp:
 *           type: string
 *           format: date-time
 *           description: ISO 8601时间戳
 *           example: "2024-07-09T14:30:00Z"
 *         status:
 *           type: string
 *           enum: [active, suspended, terminated]
 *           description: 上下文当前状态
 *           example: "active"
 *         lifecycle_stage:
 *           type: string
 *           enum: [planning, executing, monitoring, completed]
 *           description: 生命周期阶段
 *           example: "planning"
 *         name:
 *           type: string
 *           minLength: 1
 *           maxLength: 255
 *           description: 上下文名称
 *           example: "My Project Context"
 *         shared_state:
 *           type: object
 *           description: 共享状态数据
 *           additionalProperties: true
 *           example:
 *             environment: "development"
 *             debug: true
 */
```

## 🏗️ 架构文档自动生成

### 依赖关系图生成
```typescript
// scripts/generate-dependency-graph.ts
import { spawn } from 'child_process';
import * as fs from 'fs';

/**
 * 生成模块依赖关系图
 * 
 * 使用madge工具分析TypeScript代码的依赖关系，
 * 并生成可视化的依赖图表。
 */
async function generateDependencyGraph(): Promise<void> {
  console.log('📊 Generating dependency graph...');
  
  try {
    // 生成依赖关系数据
    await execCommand('madge --ts-config tsconfig.json --json src > dependency-data.json');
    
    // 生成图形文件
    await execCommand('madge --ts-config tsconfig.json --image dependency-graph.svg src');
    
    // 检查循环依赖
    await execCommand('madge --ts-config tsconfig.json --circular src');
    
    console.log('✅ Dependency graph generated successfully');
  } catch (error) {
    console.error('❌ Failed to generate dependency graph:', error);
    throw error;
  }
}

function execCommand(command: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const child = spawn(command, { shell: true });
    child.on('close', (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Command failed with code ${code}`));
      }
    });
  });
}
```

### API架构图生成
```yaml
# .github/workflows/docs-generation.yml
name: Auto Documentation Generation

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Generate JSDoc
        run: npm run docs:generate
      
      - name: Generate OpenAPI docs
        run: npm run swagger:generate
      
      - name: Generate dependency graph
        run: npm run deps:graph
      
      - name: Generate architecture diagrams
        run: |
          npm install -g @mermaid-js/mermaid-cli
          mmdc -i docs/architecture.mmd -o docs/architecture.svg
      
      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
```

## 📋 文档模板系统

### README模板
```markdown
# {{PROJECT_NAME}}

> {{PROJECT_DESCRIPTION}}

## 🚀 快速开始

### 安装

\`\`\`bash
npm install {{PACKAGE_NAME}}
\`\`\`

### 基础使用

\`\`\`typescript
{{BASIC_USAGE_EXAMPLE}}
\`\`\`

## 📚 API文档

### {{MODULE_NAME}}

{{#each METHODS}}
#### {{name}}

{{description}}

**参数:**
{{#each parameters}}
- `{{name}}` ({{type}}) - {{description}}
{{/each}}

**返回值:** `{{returnType}}`

**示例:**
\`\`\`typescript
{{example}}
\`\`\`

{{/each}}

## 📄 更多文档

- [API参考]({{API_DOCS_URL}})
- [架构设计]({{ARCHITECTURE_DOCS_URL}})
- [开发指南]({{DEV_GUIDE_URL}})

## 📝 许可证

{{LICENSE}}
```

### 变更日志模板
```markdown
# 变更日志

## [{{VERSION}}] - {{DATE}}

### Added
{{#each ADDED}}
- {{.}}
{{/each}}

### Changed
{{#each CHANGED}}
- {{.}}
{{/each}}

### Fixed
{{#each FIXED}}
- {{.}}
{{/each}}

### Security
{{#each SECURITY}}
- {{.}}
{{/each}}
```

## 🔄 文档同步机制

### Git Hook配置
```bash
#!/bin/sh
# .git/hooks/pre-commit

echo "📝 Generating documentation..."

# 更新API文档
npm run docs:api

# 检查JSDoc覆盖率
npm run docs:coverage

# 验证文档链接
npm run docs:validate

# 添加生成的文档到提交
git add docs/
```

### 自动文档更新脚本
```typescript
// scripts/update-docs.ts
import { execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';

/**
 * 自动更新文档脚本
 * 
 * 在代码变更时自动更新相关文档，确保文档与代码同步。
 */
class DocumentationUpdater {
  /**
   * 更新API文档
   */
  public async updateApiDocs(): Promise<void> {
    console.log('📄 Updating API documentation...');
    
    // 生成TypeScript类型文档
    execSync('npx typedoc src/index.ts');
    
    // 生成OpenAPI规范
    execSync('npx swagger-jsdoc -d swaggerDef.js src/**/*.ts -o docs/openapi.json');
    
    // 生成Postman集合
    execSync('npx openapi-to-postman -s docs/openapi.json -o docs/postman-collection.json');
  }

  /**
   * 更新架构文档
   */
  public async updateArchitectureDocs(): Promise<void> {
    console.log('🏗️ Updating architecture documentation...');
    
    // 生成模块依赖图
    execSync('npx madge --image docs/dependency-graph.svg src');
    
    // 更新架构图表
    execSync('npx mmdc -i docs/architecture.mmd -o docs/architecture.svg');
  }

  /**
   * 验证文档完整性
   */
  public async validateDocs(): Promise<void> {
    console.log('✅ Validating documentation...');
    
    // 检查链接有效性
    execSync('npx markdown-link-check docs/**/*.md');
    
    // 验证API文档示例
    execSync('npm run test:api-examples');
  }
}

// 执行文档更新
const updater = new DocumentationUpdater();
await updater.updateApiDocs();
await updater.updateArchitectureDocs();
await updater.validateDocs();

console.log('📚 Documentation update completed!');
```

## ✅ 自动文档检查清单

文档生成前确认：
- [ ] JSDoc注释完整覆盖所有公共API
- [ ] 参数和返回值类型准确
- [ ] 包含实用的代码示例
- [ ] 错误处理场景说明清楚
- [ ] 版本信息和作者信息正确
- [ ] 相关链接和引用有效
- [ ] 自动生成工具配置正确
- [ ] 文档格式和样式统一

---

> **重要**: 自动文档生成确保代码和文档的一致性，减少手动维护工作量，提高文档质量。
description: "MPLP自动文档生成规则 - 定义文档自动生成、更新和维护的规范和流程"
globs: ["**/*.md", "**/docs/**", "**/README.md", "**/*.ts", "**/*.js"]
alwaysApply: true
---
 