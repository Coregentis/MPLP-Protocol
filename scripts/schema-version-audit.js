/**
 * MPLP SchemaÁâàÊú¨ÂÆ°ËÆ°Â∑•ÂÖ∑
 * 
 * ÂàÜÊûêÊâÄÊúâSchemaÊñá‰ª∂ÁöÑÁâàÊú¨‰∏ÄËá¥ÊÄßÔºåÂª∫Á´ãÁâàÊú¨Âü∫Á∫ø
 * ‰∏•Ê†ºÈÅµÂæ™SchemaÈ©±Âä®ÂºÄÂèëËßÑÂàô
 */

const fs = require('fs');
const path = require('path');

class SchemaVersionAuditor {
  constructor() {
    this.schemasDir = path.join(__dirname, '../src/schemas');
    this.schemaFiles = [
      'context-protocol.json',
      'plan-protocol.json', 
      'confirm-protocol.json',
      'trace-protocol.json',
      'role-protocol.json',
      'extension-protocol.json'
    ];
    this.versionReport = {
      timestamp: new Date().toISOString(),
      schemas: {},
      conflicts: [],
      recommendations: []
    };
  }

  /**
   * ÊâßË°åÂÆåÊï¥ÁöÑÁâàÊú¨ÂÆ°ËÆ°
   */
  async audit() {
    console.log('üîç ÂºÄÂßãSchemaÁâàÊú¨ÂÆ°ËÆ°...\n');
    
    // 1. ÂàÜÊûêÊØè‰∏™SchemaÊñá‰ª∂
    for (const file of this.schemaFiles) {
      await this.analyzeSchema(file);
    }
    
    // 2. Ê£ÄÊµãÁâàÊú¨ÂÜ≤Á™Å
    this.detectVersionConflicts();
    
    // 3. ÁîüÊàêÂª∫ËÆÆ
    this.generateRecommendations();
    
    // 4. ËæìÂá∫Êä•Âëä
    this.printReport();
    
    // 5. ‰øùÂ≠òÂÆ°ËÆ°Êä•Âëä
    await this.saveReport();
    
    return this.versionReport;
  }

  /**
   * ÂàÜÊûêÂçï‰∏™SchemaÊñá‰ª∂
   */
  async analyzeSchema(filename) {
    try {
      const filePath = path.join(this.schemasDir, filename);
      const content = fs.readFileSync(filePath, 'utf8');
      const schema = JSON.parse(content);
      
      const moduleName = filename.replace('-protocol.json', '');
      
      this.versionReport.schemas[moduleName] = {
        filename,
        version: this.extractVersion(schema),
        protocolVersion: schema.properties?.protocol_version?.const || schema.properties?.protocol_version?.pattern,
        schemaId: schema.$id,
        title: schema.title,
        lastModified: fs.statSync(filePath).mtime.toISOString(),
        requiredFields: schema.required || [],
        fieldCount: Object.keys(schema.properties || {}).length,
        enumFields: this.extractEnumFields(schema)
      };
      
      console.log(`‚úÖ ÂàÜÊûêÂÆåÊàê: ${moduleName}`);
    } catch (error) {
      console.error(`‚ùå ÂàÜÊûêÂ§±Ë¥•: ${filename}`, error.message);
      this.versionReport.schemas[filename] = {
        error: error.message,
        status: 'FAILED'
      };
    }
  }

  /**
   * ÊèêÂèñSchemaÁâàÊú¨‰ø°ÊÅØ
   */
  extractVersion(schema) {
    return {
      schema: schema.version || 'N/A',
      protocol: schema.properties?.protocol_version?.const || 
                schema.properties?.protocol_version?.pattern || 'N/A',
      schemaSpec: schema.$schema || 'N/A'
    };
  }

  /**
   * ÊèêÂèñÊûö‰∏æÂ≠óÊÆµ
   */
  extractEnumFields(schema, prefix = '') {
    const enums = {};
    
    if (schema.properties) {
      for (const [key, value] of Object.entries(schema.properties)) {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        
        if (value.enum) {
          enums[fullKey] = value.enum;
        }
        
        if (value.properties) {
          Object.assign(enums, this.extractEnumFields(value, fullKey));
        }
        
        if (value.items && value.items.properties) {
          Object.assign(enums, this.extractEnumFields(value.items, `${fullKey}[]`));
        }
      }
    }
    
    if (schema.$defs) {
      for (const [key, value] of Object.entries(schema.$defs)) {
        Object.assign(enums, this.extractEnumFields(value, `$defs.${key}`));
      }
    }
    
    return enums;
  }

  /**
   * Ê£ÄÊµãÁâàÊú¨ÂÜ≤Á™Å
   */
  detectVersionConflicts() {
    const versions = {};
    const protocolVersions = {};
    
    // Êî∂ÈõÜÊâÄÊúâÁâàÊú¨
    for (const [module, info] of Object.entries(this.versionReport.schemas)) {
      if (info.error) continue;
      
      const schemaVer = info.version.schema;
      const protocolVer = info.version.protocol;
      
      if (!versions[schemaVer]) versions[schemaVer] = [];
      if (!protocolVersions[protocolVer]) protocolVersions[protocolVer] = [];
      
      versions[schemaVer].push(module);
      protocolVersions[protocolVer].push(module);
    }
    
    // Ê£ÄÊµãÂÜ≤Á™Å
    if (Object.keys(versions).length > 1) {
      this.versionReport.conflicts.push({
        type: 'SCHEMA_VERSION_MISMATCH',
        description: 'SchemaÁâàÊú¨‰∏ç‰∏ÄËá¥',
        details: versions
      });
    }
    
    if (Object.keys(protocolVersions).length > 1) {
      this.versionReport.conflicts.push({
        type: 'PROTOCOL_VERSION_MISMATCH', 
        description: 'ÂçèËÆÆÁâàÊú¨‰∏ç‰∏ÄËá¥',
        details: protocolVersions
      });
    }
  }

  /**
   * ÁîüÊàêÁâàÊú¨Áªü‰∏ÄÂª∫ËÆÆ
   */
  generateRecommendations() {
    const schemas = this.versionReport.schemas;
    const validSchemas = Object.entries(schemas).filter(([_, info]) => !info.error);
    
    if (this.versionReport.conflicts.length > 0) {
      this.versionReport.recommendations.push({
        priority: 'HIGH',
        action: 'UNIFY_VERSIONS',
        description: 'Áªü‰∏ÄÊâÄÊúâSchemaÁâàÊú¨Âè∑',
        details: {
          recommendedVersion: '1.0.1',
          affectedSchemas: validSchemas.map(([name]) => name)
        }
      });
    }
    
    // Ê£ÄÊü•ÂçèËÆÆÁâàÊú¨‰∏ÄËá¥ÊÄß
    const protocolVersions = validSchemas.map(([_, info]) => info.version.protocol);
    const uniqueProtocolVersions = [...new Set(protocolVersions)];
    
    if (uniqueProtocolVersions.length > 1) {
      this.versionReport.recommendations.push({
        priority: 'CRITICAL',
        action: 'FREEZE_PROTOCOL_VERSION',
        description: 'ÂÜªÁªìÂçèËÆÆÁâàÊú¨ÔºåÈò≤Ê≠¢ÂºÄÂèëÊúüÈó¥ÂèòÊõ¥',
        details: {
          recommendedProtocolVersion: '1.0.1',
          currentVersions: uniqueProtocolVersions
        }
      });
    }
    
    // SchemaÊ≤ªÁêÜÂª∫ËÆÆ
    this.versionReport.recommendations.push({
      priority: 'MEDIUM',
      action: 'IMPLEMENT_VERSION_GOVERNANCE',
      description: 'ÂÆûÊñΩSchemaÁâàÊú¨Ê≤ªÁêÜÊú∫Âà∂',
      details: {
        actions: [
          'Âª∫Á´ãSchemaÁâàÊú¨ÈîÅÂÆöÊú∫Âà∂',
          'ÂÆûÊñΩÁâàÊú¨ÂèòÊõ¥ÂÆ°ÊâπÊµÅÁ®ã',
          'Ê∑ªÂä†Ëá™Âä®ÂåñÁâàÊú¨Ê£ÄÊü•',
          'Âª∫Á´ãÁâàÊú¨ÂÖºÂÆπÊÄßÊµãËØï'
        ]
      }
    });
  }

  /**
   * ÊâìÂç∞ÂÆ°ËÆ°Êä•Âëä
   */
  printReport() {
    console.log('\nüìä SchemaÁâàÊú¨ÂÆ°ËÆ°Êä•Âëä');
    console.log('='.repeat(60));
    
    // ÁâàÊú¨Ê¶ÇËßà
    console.log('\nüìã ÁâàÊú¨Ê¶ÇËßà:');
    for (const [module, info] of Object.entries(this.versionReport.schemas)) {
      if (info.error) {
        console.log(`‚ùå ${module}: ÈîôËØØ - ${info.error}`);
      } else {
        console.log(`‚úÖ ${module}: Schema v${info.version.schema}, Protocol v${info.version.protocol}`);
      }
    }
    
    // ÂÜ≤Á™ÅÊä•Âëä
    if (this.versionReport.conflicts.length > 0) {
      console.log('\n‚ö†Ô∏è  ÁâàÊú¨ÂÜ≤Á™Å:');
      this.versionReport.conflicts.forEach((conflict, i) => {
        console.log(`${i + 1}. ${conflict.description}`);
        console.log(`   Á±ªÂûã: ${conflict.type}`);
        console.log(`   ËØ¶ÊÉÖ: ${JSON.stringify(conflict.details, null, 2)}`);
      });
    } else {
      console.log('\n‚úÖ Êú™ÂèëÁé∞ÁâàÊú¨ÂÜ≤Á™Å');
    }
    
    // Âª∫ËÆÆ
    if (this.versionReport.recommendations.length > 0) {
      console.log('\nüí° Âª∫ËÆÆ:');
      this.versionReport.recommendations.forEach((rec, i) => {
        console.log(`${i + 1}. [${rec.priority}] ${rec.description}`);
        console.log(`   Êìç‰Ωú: ${rec.action}`);
        if (rec.details) {
          console.log(`   ËØ¶ÊÉÖ: ${JSON.stringify(rec.details, null, 2)}`);
        }
      });
    }
    
    console.log('\n='.repeat(60));
  }

  /**
   * ‰øùÂ≠òÂÆ°ËÆ°Êä•Âëä
   */
  async saveReport() {
    const reportPath = path.join(__dirname, '../docs/schema-version-audit-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(this.versionReport, null, 2));
    console.log(`üìÑ ÂÆ°ËÆ°Êä•ÂëäÂ∑≤‰øùÂ≠ò: ${reportPath}`);
  }
}

// ÊâßË°åÂÆ°ËÆ°
if (require.main === module) {
  const auditor = new SchemaVersionAuditor();
  auditor.audit()
    .then(() => {
      console.log('\nüéâ SchemaÁâàÊú¨ÂÆ°ËÆ°ÂÆåÊàê!');
      process.exit(0);
    })
    .catch(error => {
      console.error('‚ùå ÂÆ°ËÆ°Â§±Ë¥•:', error);
      process.exit(1);
    });
}

module.exports = SchemaVersionAuditor; 