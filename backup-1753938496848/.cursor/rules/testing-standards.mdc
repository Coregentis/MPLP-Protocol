description: "MPLP项目测试标准 - 定义所有测试类型、实现标准、厂商中立验证和性能测试规范"
globs: ["**/*.test.ts", "**/*.spec.ts", "**/tests/**", "**/test/**", "**/mocks/**", "**/fixtures/**"]
alwaysApply: true
---

# MPLP 测试标准规则

> **规则版本**: v2.1.0  
> **创建时间**: 2025-07-27  
> **更新时间**: 2025-08-21  
> **适用范围**: 所有测试文件和测试配置  
> **强制等级**: 🚨 **高优先级** - 所有测试必须符合规范

## 🎯 测试核心原则

### 基础原则
- **基于实际代码实现**: 所有测试必须基于实际代码实现而非假设或臆测
- **Schema驱动**: 所有测试数据必须符合Schema定义
- **厂商中立**: 测试代码不应包含任何厂商特定名称或实现
- **高覆盖率**: 单元测试覆盖率≥90%，集成测试覆盖率≥80%
- **隔离性**: 测试应该相互独立，不依赖执行顺序
- **可重复性**: 测试结果应该稳定且可重现
- **性能验证**: 性能关键部分必须有专门的性能测试
- **零错误原则**: 测试文件必须没有任何编译错误和运行时错误

## 📋 测试文件创建流程

### 1. 测试文件创建前检查清单
```
在创建测试文件之前，必须完成以下检查：

1. ✅ 检查并理解被测组件的实际实现
   - 打开并仔细阅读要测试的源代码文件
   - 理解所有公共方法的签名、参数和返回类型
   - 了解组件的依赖关系和外部接口

2. ✅ 检查组件的接口定义
   - 找到并阅读相关的接口定义文件
   - 确认组件实现的接口方法

3. ✅ 检查相关的Schema定义
   - 找到并阅读相关的JSON Schema文件
   - 确保理解数据结构和字段定义

4. ✅ 准备测试数据工厂
   - 使用或创建符合Schema的测试数据工厂
   - 确保测试数据覆盖各种情况
```

## 🔍 强制执行测试前检查清单

为确保测试质量和符合实际代码实现，每次创建或修改测试文件前**必须**完成以下强制检查流程：

### 1. 源代码分析（强制）
- [ ] 已完整阅读并理解源代码文件 `src/modules/{module}/{file}.ts`
- [ ] 已记录所有公共方法及其签名、参数类型和返回类型
- [ ] 已分析所有依赖项和注入项的类型和用途
- [ ] 已理解代码中的错误处理和边界情况处理
- [ ] 已确认所有类型定义和接口实现

### 2. 接口检查（强制）
- [ ] 已查找并分析接口文件 `src/interfaces/{interface}.interface.ts`
- [ ] 已确认所有接口方法与实现完全匹配
- [ ] 已记录接口类型定义和约束条件
- [ ] 已验证接口与实现之间的一致性
- [ ] 已理解泛型类型和类型参数的用法

### 3. Schema验证（强制）
- [ ] 已检查Schema文件 `src/schemas/{schema}.json`
- [ ] 已确认所有字段名称、类型和必填项
- [ ] 已理解Schema中的枚举值、格式和约束条件
- [ ] 已验证Schema版本与代码实现的兼容性
- [ ] 已确认Schema中的嵌套结构和引用关系

### 4. 测试数据准备（强制）
- [ ] 已创建符合Schema的测试数据工厂
- [ ] 已准备正常场景、边界场景和错误场景的测试数据
- [ ] 已验证测试数据与Schema定义完全匹配
- [ ] 已确保测试数据覆盖所有可能的输入情况
- [ ] 已创建专门的工厂函数处理复杂类型

### 5. 模拟对象创建（强制）
- [ ] 已为所有依赖创建基于接口类型的模拟对象
- [ ] 已确保模拟方法与实际接口完全匹配
- [ ] 已设置适当的模拟返回值和行为
- [ ] 已验证模拟对象的类型安全性
- [ ] 已创建专门的模拟工厂函数确保类型正确

### 6. 测试覆盖验证（强制）
- [ ] 已确认测试覆盖所有公共方法
- [ ] 已确认测试覆盖所有正常和异常流程
- [ ] 已确认测试覆盖所有条件分支
- [ ] 已确认测试覆盖所有边界条件
- [ ] 已确认测试覆盖所有错误处理路径

### 7. 编译和类型检查（强制）
- [ ] 已使用TypeScript编译器验证测试文件
- [ ] 已确认没有类型错误和接口不匹配
- [ ] 已验证所有导入路径正确
- [ ] 已确认测试文件与被测代码完全兼容
- [ ] 已确保模拟函数类型与接口定义完全匹配

### 8. 测试执行验证（强制）
- [ ] 已执行测试并确认所有测试通过
- [ ] 已验证没有任何编译错误
- [ ] 已验证没有任何运行时错误
- [ ] 已确认测试覆盖率达到要求
- [ ] 已确认测试执行时间在合理范围内

**注意**: 这个检查清单不是可选的，而是强制执行的。每次创建或修改测试文件前必须完成所有检查项，并在测试文件顶部添加注释确认已完成检查。未完成检查的测试文件将被视为不合规，必须重新执行检查流程。

**严格规定**: 测试文件必须通过编译且没有任何类型错误。任何类型错误必须在提交前解决，不允许使用类型断言（as any）或忽略错误的方式规避类型检查。

## 🔍 模拟对象创建规范

为确保模拟对象的类型安全性，必须遵循以下规范：

### 1. 使用专门的模拟工厂函数
```typescript
// ✅ 正确：使用模拟工厂函数确保类型安全
function createMockLifecycleHook(): jest.MockedFunction<LifecycleHook> {
  return jest.fn().mockImplementation(async () => {}) as jest.MockedFunction<LifecycleHook>;
}

// 使用模拟工厂函数
const mockHook = createMockLifecycleHook();

// ❌ 错误：直接使用jest.fn()可能导致类型不匹配
const mockHook = jest.fn();
```

### 2. 确保模拟对象实现完整接口
```typescript
// ✅ 正确：模拟对象实现完整接口
const mockRepository: jest.Mocked<IContextRepository> = {
  findById: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  exists: jest.fn(),
  findByFilter: jest.fn(),
  count: jest.fn()
};

// ❌ 错误：模拟对象缺少接口方法
const mockRepository = {
  findById: jest.fn(),
  create: jest.fn()
  // 缺少其他必要方法
};
```

### 3. 正确处理异步函数模拟
```typescript
// ✅ 正确：明确返回Promise
const mockAsyncFunction = jest.fn().mockImplementation(async () => {
  return { success: true };
});

// ✅ 正确：使用mockResolvedValue
const mockAsyncFunction = jest.fn().mockResolvedValue({ success: true });

// ❌ 错误：返回类型不明确
const mockAsyncFunction = jest.fn().mockImplementation(() => {
  return { success: true }; // 缺少async/await或Promise
});
```

### 4. 正确处理错误模拟
```typescript
// ✅ 正确：使用类型化错误
const error = new ValidationError('Invalid input');
mockFunction.mockRejectedValue(error);

// ❌ 错误：使用未类型化错误
mockFunction.mockRejectedValue('Something went wrong');
```

## 📝 测试文件顶部注释规范

每个测试文件必须在顶部包含以下注释，确认已完成所有强制检查：

```typescript
/**
 * {Module}模块 - {Class}单元测试
 * 
 * 测试{Class}的核心功能，确保符合Schema定义和厂商中立原则
 * 
 * @version v{x.y.z}
 * @created {YYYY-MM-DD}T{HH:mm:ss}+08:00
 * @compliance 100% Schema合规性 - 完全匹配{schema-file}.json Schema定义
 * 
 * @强制检查确认
 * - [x] 已完成源代码分析
 * - [x] 已完成接口检查
 * - [x] 已完成Schema验证
 * - [x] 已完成测试数据准备
 * - [x] 已完成模拟对象创建
 * - [x] 已完成测试覆盖验证
 * - [x] 已完成编译和类型检查
 * - [x] 已完成测试执行验证
 */
```

### 2. 测试文件结构
```typescript
/**
 * {Module}模块 - {Class}单元测试
 * 
 * 测试{Class}的核心功能，确保符合Schema定义和厂商中立原则
 * 
 * @version v{x.y.z}
 * @created {YYYY-MM-DD}T{HH:mm:ss}+08:00
 * @compliance 100% Schema合规性 - 完全匹配{schema-file}.json Schema定义
 * 
 * @强制检查确认
 * - [x] 已完成源代码分析
 * - [x] 已完成接口检查
 * - [x] 已完成Schema验证
 * - [x] 已完成测试数据准备
 * - [x] 已完成模拟对象创建
 * - [x] 已完成测试覆盖验证
 * - [x] 已完成编译和类型检查
 * - [x] 已完成测试执行验证
 */

// 从@jest/globals导入Jest函数
import { describe, expect, it, jest, beforeEach } from '@jest/globals';

// 导入测试工厂和其他工具
import { ... } from '../../test-utils/...';

// 导入被测组件和接口
import { TestedClass } from '../path-to-tested-class';
import { IDependency1, IDependency2 } from '../interfaces/...';

// 创建模拟对象工厂函数
function createMockDependency1(): jest.Mocked<IDependency1> {
  return {
    method1: jest.fn(),
    method2: jest.fn()
  } as jest.Mocked<IDependency1>;
}

describe('TestedClass', () => {
  let instance: TestedClass;
  let mockDependency1: jest.Mocked<IDependency1>;
  
  beforeEach(() => {
    // 重置所有模拟
    jest.clearAllMocks();
    
    // 创建模拟对象
    mockDependency1 = createMockDependency1();
    
    // 创建测试实例
    instance = new TestedClass(mockDependency1, ...);
  });
  
  // 按方法分组进行测试
  describe('methodName', () => {
    it('应该成功完成预期行为', async () => {
      // 准备测试数据
      const testInput = {...};
      mockDependency1.method1.mockResolvedValue(...);
      
      // 执行测试
      const result = await instance.methodName(testInput);
      
      // 验证结果
      expect(result).toEqual(...);
      
      // 验证依赖方法调用
      expect(mockDependency1.method1).toHaveBeenCalledWith(...);
    });
    
    it('应该处理错误情况', async () => {
      // 准备测试数据
      const error = new Error('测试错误');
      mockDependency1.method1.mockRejectedValue(error);
      
      // 执行测试
      const result = await instance.methodName(...);
      
      // 验证错误处理
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });
});
```

## 🧪 单元测试规范

### 1. 模拟对象创建
```typescript
// ✅ 正确: 使用接口类型创建模拟对象
const mockContextRepository = {
  findById: jest.fn(),
  create: jest.fn(),
  update: jest.fn()
} as jest.Mocked<IContextRepository>;

// ❌ 错误: 未指定类型或使用具体实现类型
const mockContextRepository = {
  findById: jest.fn(),
  create: jest.fn()
};
```

### 2. 测试用例组织
```typescript
// ✅ 正确: 按方法分组测试，每个方法测试多个场景
describe('ContextManager', () => {
  describe('createContext', () => {
    it('应成功创建上下文', async () => {...});
    it('应处理验证失败', async () => {...});
    it('应处理数据库错误', async () => {...});
  });
  
  describe('getContext', () => {
    it('应成功获取上下文', async () => {...});
    it('应处理上下文不存在', async () => {...});
  });
});

// ❌ 错误: 测试用例组织混乱
describe('ContextManager', () => {
  it('应成功创建上下文', async () => {...});
  it('应成功获取上下文', async () => {...});
});
```

### 3. 测试用例命名
```typescript
// ✅ 正确: 使用"应该xx"格式描述预期行为
it('应成功创建上下文', async () => {...});
it('应处理验证错误', async () => {...});
it('应返回正确的分页结果', async () => {...});

// ❌ 错误: 命名不清晰或不表述预期
it('createContext', async () => {...});
it('测试错误处理', async () => {...});
```

### 4. 测试准备-执行-验证模式
```typescript
// ✅ 正确: 清晰的准备-执行-验证结构
it('应成功创建上下文', async () => {
  // 准备 (Arrange)
  const testData = createTestContextRequest();
  mockRepository.create.mockResolvedValue(createTestContext());
  
  // 执行 (Act)
  const result = await contextManager.createContext(testData);
  
  // 验证 (Assert)
  expect(result.success).toBe(true);
  expect(result.data).toBeDefined();
  expect(mockRepository.create).toHaveBeenCalledWith(expect.objectContaining({
    name: testData.name
  }));
});
```

## 📊 测试数据管理

### 使用测试数据工厂
```typescript
// ✅ 正确: 使用测试工厂创建数据
const testContext = createTestContext({
  name: 'Custom Test Context'
});

// ❌ 错误: 硬编码测试数据
const testContext = {
  context_id: '123',
  name: 'Test',
  // 大量硬编码数据...
};
```

### 边界条件测试
```typescript
// ✅ 正确: 测试边界条件
describe('validateInput', () => {
  const testCases = [
    { name: 'empty string', value: '', expected: false },
    { name: 'max length', value: 'A'.repeat(255), expected: true },
    { name: 'exceeds max', value: 'A'.repeat(256), expected: false }
  ];
  
  test.each(testCases)('$name', ({ value, expected }) => {
    const result = validator.validate({ name: value });
    expect(result.valid).toBe(expected);
  });
});
```

## 🛠️ 测试最佳实践

### 1. 始终基于实际代码实现
```
在编写测试之前，必须先查看和理解要测试的实际代码实现。测试应该基于实际实现，而不是基于假设或臆测。测试不应尝试测试不存在的方法或行为。
```

### 2. 测试覆盖所有公共方法
```
对于类或模块，应测试所有公共方法。确保测试覆盖正常情况和错误情况。
```

### 3. 模拟所有外部依赖
```
在单元测试中，应该模拟所有外部依赖，如数据库、API调用、文件系统等。这样可以确保测试的隔离性和可重复性。
```

### 4. 使用类型安全的模拟
```
所有模拟对象必须类型安全，与实际接口完全匹配。使用专门的模拟工厂函数确保类型正确。
```

### 5. 测试错误处理
```
测试应该覆盖所有错误处理路径，确保系统在异常情况下的行为符合预期。
```

### 6. 验证测试执行
```
测试编写完成后，必须执行测试并确认所有测试通过，没有任何编译错误和运行时错误。
```

## 📋 测试提交前检查清单

在提交测试代码前，必须完成以下检查：

1. **编译检查**: 确保没有任何TypeScript编译错误
2. **测试执行**: 确保所有测试通过，没有失败或跳过的测试
3. **覆盖率检查**: 确保测试覆盖率达到要求（≥90%）
4. **类型安全**: 确保所有模拟对象类型安全，与实际接口完全匹配
5. **代码质量**: 确保测试代码符合项目代码规范
6. **注释完整**: 确保测试文件顶部注释完整，包含所有强制检查确认

**注意**: 任何违反上述规定的测试代码都将被拒绝合并，必须修复所有问题后重新提交。

---

**规则创建**: MPLP测试团队  
**维护责任**: 所有开发者  
**审查周期**: 每个开发阶段结束后审查