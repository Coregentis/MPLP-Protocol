# MPLP Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà

> **üåê Ë®ÄË™û„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥**: [English](../../en/testing/interoperability-testing.md) | [‰∏≠Êñá](../../zh-CN/testing/interoperability-testing.md) | [Êó•Êú¨Ë™û](interoperability-testing.md) | [ÌïúÍµ≠Ïñ¥](../../ko/testing/interoperability-testing.md) | [Espa√±ol](../../es/testing/interoperability-testing.md) | [Fran√ßais](../../fr/testing/interoperability-testing.md) | [–†—É—Å—Å–∫–∏–π](../../ru/testing/interoperability-testing.md) | [Deutsch](../../de/testing/interoperability-testing.md)



**„Éû„É´„ÉÅ„Ç®„Éº„Ç∏„Çß„É≥„Éà„Éó„É≠„Éà„Ç≥„É´„É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É† - Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà v1.0.0-alpha**

[![Áõ∏‰∫íÈÅãÁî®ÊÄß](https://img.shields.io/badge/interoperability-Êú¨Áï™ÂØæÂøú-brightgreen.svg)](./README.md)
[![‰∫íÊèõÊÄß](https://img.shields.io/badge/compatibility-10%2F10%20„É¢„Ç∏„É•„Éº„É´-brightgreen.svg)](../implementation/multi-language-support.md)
[![„ÉÜ„Çπ„Éà](https://img.shields.io/badge/testing-2869%2F2869%20ÂêàÊ†º-brightgreen.svg)](./performance-benchmarking.md)
[![ÂÆüË£Ö](https://img.shields.io/badge/implementation-„ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†-brightgreen.svg)](./test-suites.md)
[![Ë®ÄË™û](https://img.shields.io/badge/language-Êó•Êú¨Ë™û-blue.svg)](../../en/testing/interoperability-testing.md)

---

## üéØ Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„ÉàÊ¶ÇË¶Å

„Åì„ÅÆ„Ç¨„Ç§„Éâ„ÅØ„ÄÅÁï∞„Å™„Çã„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„ÄÅ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„ÄÅ„Éê„Éº„Ç∏„Éß„É≥„ÄÅ„Çµ„Éº„Éâ„Éë„Éº„ÉÜ„Ç£„Ç∑„Çπ„ÉÜ„É†Èñì„Åß„ÅÆMPLPÁõ∏‰∫íÈÅãÁî®ÊÄß„ÇíÊ§úË®º„Åô„Çã„Åü„ÇÅ„ÅÆÂåÖÊã¨ÁöÑ„Å™„ÉÜ„Çπ„ÉàÊà¶Áï•„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇÂ§öÊßò„Å™MPLPÂÆüË£ÖÈñì„ÅÆ„Ç∑„Éº„É†„É¨„Çπ„Å™Áµ±Âêà„Å®ÈÄö‰ø°„Çí‰øùË®º„Åó„Åæ„Åô„ÄÇ

### **Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà„Çπ„Ç≥„Éº„Éó**
- **„ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„ÉÜ„Çπ„Éà**: Windows, Linux, macOS, „Ç≥„É≥„ÉÜ„ÉäÁí∞Â¢É
- **Â§öË®ÄË™û„ÉÜ„Çπ„Éà**: TypeScript, Python, Java, Go, C#, Rust
- **„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß**: ÂæåÊñπ„Åä„Çà„Å≥ÂâçÊñπ‰∫íÊèõÊÄßÊ§úË®º
- **„Éó„É≠„Éà„Ç≥„É´Áõ∏‰∫íÈÅãÁî®ÊÄß**: HTTP/HTTPS, WebSocket, gRPC, TCP/UDP
- **„Éá„Éº„Çø„Éï„Ç©„Éº„Éû„ÉÉ„Éà‰∫íÊèõÊÄß**: JSON, Protocol Buffers, MessagePack
- **„Çµ„Éº„Éâ„Éë„Éº„ÉÜ„Ç£Áµ±Âêà**: Â§ñÈÉ®„Ç∑„Çπ„ÉÜ„É†„Å®„Çµ„Éº„Éì„ÇπÁµ±Âêà

### **Áõ∏‰∫íÈÅãÁî®ÊÄßÊ®ôÊ∫ñ**
- **„Éó„É≠„Éà„Ç≥„É´Ê∫ñÊã†**: ÂÆåÂÖ®„Å™L1-L3„Éó„É≠„Éà„Ç≥„É´„Çπ„Çø„ÉÉ„ÇØ‰∫íÊèõÊÄß
- **„Çπ„Ç≠„Éº„Éû‰∫íÊèõÊÄß**: Ë®ÄË™ûÈñì„Éá„É•„Ç¢„É´ÂëΩÂêçË¶èÁ¥Ñ
- **„É°„ÉÉ„Çª„Éº„Ç∏„Éï„Ç©„Éº„Éû„ÉÉ„Éà**: ‰∏ÄË≤´„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥/„Éá„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
- **„Éà„É©„É≥„Çπ„Éù„Éº„Éà„Éó„É≠„Éà„Ç≥„É´**: „Éû„É´„ÉÅ„Éó„É≠„Éà„Ç≥„É´ÈÄö‰ø°„Çµ„Éù„Éº„Éà
- **„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ**: „Çª„Éû„É≥„ÉÜ„Ç£„ÉÉ„ÇØ„Éê„Éº„Ç∏„Éß„Éã„É≥„Ç∞„Å®‰∫íÊèõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ

---

## üåê „ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà

### **„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†‰∫íÊèõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ**

#### **„Ç™„Éö„É¨„Éº„ÉÜ„Ç£„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà**
```typescript
// „ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
describe('„ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†Áõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  const platforms = [
    { name: 'Windows', version: '10/11', architecture: 'x64' },
    { name: 'Linux', version: 'Ubuntu 20.04/22.04', architecture: 'x64/arm64' },
    { name: 'macOS', version: '12.0+', architecture: 'x64/arm64' },
    { name: 'Container', version: 'Docker/Kubernetes', architecture: 'multi-arch' }
  ];

  platforms.forEach(platform => {
    describe(`${platform.name} „Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†`, () => {
      let mplpClient: MPLPClient;

      beforeEach(async () => {
        mplpClient = new MPLPClient({
          platform: platform.name.toLowerCase(),
          architecture: platform.architecture,
          version: platform.version
        });
        await mplpClient.initialize();
      });

      afterEach(async () => {
        await mplpClient.cleanup();
      });

      it('Âü∫Êú¨ÁöÑ„Å™MPLPÊìç‰Ωú„ÇíÂÆüË°å„Åß„Åç„Çã', async () => {
        // Context‰ΩúÊàê„ÉÜ„Çπ„Éà
        const context = await mplpClient.context.createContext({
          contextId: `platform-test-${platform.name.toLowerCase()}`,
          contextType: 'platform_compatibility_test',
          contextData: { 
            platform: platform.name,
            architecture: platform.architecture,
            version: platform.version
          },
          createdBy: 'platform-compatibility-test'
        });

        expect(context.contextId).toBeDefined();
        expect(context.contextType).toBe('platform_compatibility_test');

        // Plan‰ΩúÊàê„ÉÜ„Çπ„Éà
        const plan = await mplpClient.plan.createPlan({
          planId: `plan-${platform.name.toLowerCase()}`,
          planType: 'platform_test_plan',
          planData: {
            targetPlatform: platform.name,
            testObjectives: ['basic_operations', 'performance', 'compatibility']
          },
          contextId: context.contextId
        });

        expect(plan.planId).toBeDefined();
        expect(plan.planType).toBe('platform_test_plan');
      });

      it('„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†Èñì„Åß„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂ö„ÇíÊ§úË®º„Åô„Çã', async () => {
        const networkTest = await mplpClient.network.performConnectivityTest({
          protocols: ['http', 'https', 'websocket', 'grpc'],
          endpoints: [
            'http://localhost:3000',
            'https://api.mplp.dev',
            'ws://localhost:3001',
            'grpc://localhost:50051'
          ]
        });

        expect(networkTest.overallConnectivity).toBe(true);
        
        networkTest.protocolResults.forEach(result => {
          expect(result.connected).toBe(true);
          expect(result.latency).toBeLessThan(1000); // ÊúÄÂ§ß1Áßí
          expect(result.errors).toHaveLength(0);
        });
      });
    });
  });
});
```

### **„Ç≥„É≥„ÉÜ„ÉäÁí∞Â¢É„ÉÜ„Çπ„Éà**

#### **DockerÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà**
```yaml
# docker-compose.interop-test.yml
version: '3.8'

services:
  mplp-node:
    image: mplp/node:1.0.0-alpha
    environment:
      - NODE_ENV=test
      - MPLP_PROTOCOL_VERSION=1.0.0
    ports:
      - "3000:3000"
    networks:
      - mplp-test-network

  mplp-python:
    image: mplp/python:1.0.0-alpha
    environment:
      - PYTHON_ENV=test
      - MPLP_PROTOCOL_VERSION=1.0.0
    ports:
      - "3001:3001"
    networks:
      - mplp-test-network

  mplp-java:
    image: mplp/java:1.0.0-alpha
    environment:
      - JAVA_ENV=test
      - MPLP_PROTOCOL_VERSION=1.0.0
    ports:
      - "3002:3002"
    networks:
      - mplp-test-network

  test-runner:
    image: mplp/test-runner:latest
    depends_on:
      - mplp-node
      - mplp-python
      - mplp-java
    environment:
      - TEST_TYPE=interoperability
      - TARGET_SERVICES=mplp-node,mplp-python,mplp-java
    networks:
      - mplp-test-network
    command: npm run test:interop

networks:
  mplp-test-network:
    driver: bridge
```

#### **KubernetesÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà**
```yaml
# k8s-interop-test.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: mplp-interop-test
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mplp-node-service
  namespace: mplp-interop-test
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mplp-node
  template:
    metadata:
      labels:
        app: mplp-node
    spec:
      containers:
      - name: mplp-node
        image: mplp/node:1.0.0-alpha
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "test"
        - name: MPLP_PROTOCOL_VERSION
          value: "1.0.0"
---
apiVersion: v1
kind: Service
metadata:
  name: mplp-node-service
  namespace: mplp-interop-test
spec:
  selector:
    app: mplp-node
  ports:
  - port: 3000
    targetPort: 3000
  type: ClusterIP
```

---

## üî§ Â§öË®ÄË™ûÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà

### **Ë®ÄË™ûÂÆüË£Ö‰∫íÊèõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ**

#### **TypeScript ‚Üî Python Áõ∏‰∫íÈÅãÁî®ÊÄß**
```typescript
// TypeScript-PythonÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
describe('TypeScript-PythonÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  let tsClient: MPLPClient;
  let pyClient: PythonMPLPClient;

  beforeAll(async () => {
    // TypeScript„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
    tsClient = new MPLPClient({
      language: 'typescript',
      protocolVersion: '1.0.0',
      endpoint: 'http://localhost:3000'
    });

    // Python„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
    pyClient = new PythonMPLPClient({
      language: 'python',
      protocolVersion: '1.0.0',
      endpoint: 'http://localhost:3001'
    });

    await Promise.all([
      tsClient.initialize(),
      pyClient.initialize()
    ]);
  });

  afterAll(async () => {
    await Promise.all([
      tsClient.cleanup(),
      pyClient.cleanup()
    ]);
  });

  it('TypeScript„Åß‰ΩúÊàê„Åó„ÅüContext„ÇíPython„ÅßÂèñÂæó„Åß„Åç„Çã', async () => {
    // TypeScript„ÅßContext‰ΩúÊàê
    const contextData = {
      contextId: 'ts-py-interop-test',
      contextType: 'language_interop_test',
      contextData: {
        sourceLanguage: 'typescript',
        targetLanguage: 'python',
        testData: { message: 'Hello from TypeScript!' }
      },
      createdBy: 'typescript-client'
    };

    const tsContext = await tsClient.context.createContext(contextData);
    expect(tsContext.contextId).toBe(contextData.contextId);

    // Python„ÅßContextÂèñÂæó
    const pyContext = await pyClient.context.getContext(contextData.contextId);
    expect(pyContext.contextId).toBe(contextData.contextId);
    expect(pyContext.contextType).toBe(contextData.contextType);
    expect(pyContext.contextData.sourceLanguage).toBe('typescript');
  });

  it('Python„Åß‰ΩúÊàê„Åó„ÅüPlan„ÇíTypeScript„ÅßÂÆüË°å„Åß„Åç„Çã', async () => {
    // Python„ÅßPlan‰ΩúÊàê
    const planData = {
      planId: 'py-ts-plan-test',
      planType: 'cross_language_plan',
      planData: {
        sourceLanguage: 'python',
        targetLanguage: 'typescript',
        tasks: [
          { id: 'task1', type: 'data_processing', language: 'python' },
          { id: 'task2', type: 'ui_rendering', language: 'typescript' }
        ]
      },
      contextId: 'ts-py-interop-test'
    };

    const pyPlan = await pyClient.plan.createPlan(planData);
    expect(pyPlan.planId).toBe(planData.planId);

    // TypeScript„ÅßPlanÂÆüË°å
    const executionResult = await tsClient.plan.executePlan(planData.planId);
    expect(executionResult.success).toBe(true);
    expect(executionResult.completedTasks).toHaveLength(2);
  });
});
```

#### **C# ‚Üî Rust Áõ∏‰∫íÈÅãÁî®ÊÄß**
```csharp
// C#-RustÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
[TestClass]
public class CSharpRustInteroperabilityTest
{
    private MPLPClient csharpClient;
    private RustMPLPClient rustClient;

    [TestInitialize]
    public async Task SetUp()
    {
        // C#„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        csharpClient = new MPLPClient(new MPLPConfig
        {
            Language = "csharp",
            ProtocolVersion = "1.0.0",
            Endpoint = "http://localhost:3004"
        });

        // Rust„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        rustClient = new RustMPLPClient(new RustMPLPConfig
        {
            Language = "rust",
            ProtocolVersion = "1.0.0",
            Endpoint = "http://localhost:3005"
        });

        await Task.WhenAll(
            csharpClient.InitializeAsync(),
            rustClient.InitializeAsync()
        );
    }

    [TestCleanup]
    public async Task TearDown()
    {
        await Task.WhenAll(
            csharpClient.CleanupAsync(),
            rustClient.CleanupAsync()
        );
    }

    [TestMethod]
    public async Task TestCSharpRustDialogInteroperability()
    {
        // C#„ÅßDialog‰ΩúÊàê
        var dialogData = new DialogData
        {
            DialogId = "csharp-rust-dialog-test",
            DialogType = "cross_language_dialog",
            DialogData = new Dictionary<string, object>
            {
                ["sourceLanguage"] = "csharp",
                ["targetLanguage"] = "rust",
                ["participants"] = new[] { "csharp-agent", "rust-agent" }
            },
            CreatedBy = "csharp-client"
        };

        var csharpDialog = await csharpClient.Dialog.CreateDialogAsync(dialogData);
        Assert.AreEqual(dialogData.DialogId, csharpDialog.DialogId);

        // Rust„ÅßDialogÂèÇÂä†
        var rustParticipation = await rustClient.Dialog.JoinDialogAsync(
            dialogData.DialogId, "rust-agent"
        );
        Assert.IsTrue(rustParticipation.Success);

        // C#„Åã„Çâ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        var messageResult = await csharpClient.Dialog.SendMessageAsync(
            dialogData.DialogId,
            new DialogMessage
            {
                MessageId = "msg-csharp-to-rust",
                Content = "Hello from C#!",
                Sender = "csharp-agent",
                Timestamp = DateTime.UtcNow
            }
        );
        Assert.IsTrue(messageResult.Success);

        // Rust„Åß„É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°Á¢∫Ë™ç
        var receivedMessages = await rustClient.Dialog.GetMessagesAsync(
            dialogData.DialogId, limit: 1
        );
        Assert.AreEqual(1, receivedMessages.Count);
        Assert.AreEqual("Hello from C#!", receivedMessages[0].Content);
    }
}
```

#### **Python ‚Üî TypeScript „É™„Ç¢„É´„Çø„Ç§„É†ÈÄö‰ø°**
```python
# Python-TypeScript „É™„Ç¢„É´„Çø„Ç§„É†Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
import asyncio
import pytest
from mplp_python import MPLPClient as PythonMPLPClient
from mplp_typescript import MPLPClient as TypeScriptMPLPClient

class TestPythonTypeScriptRealtime:
    async def setup_method(self):
        # Python„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        self.py_client = PythonMPLPClient({
            'language': 'python',
            'protocol_version': '1.0.0',
            'endpoint': 'ws://localhost:3001',
            'realtime': True
        })

        # TypeScript„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        self.ts_client = TypeScriptMPLPClient({
            'language': 'typescript',
            'protocol_version': '1.0.0',
            'endpoint': 'ws://localhost:3000',
            'realtime': True
        })

        await asyncio.gather(
            self.py_client.initialize(),
            self.ts_client.initialize()
        )

    async def teardown_method(self):
        await asyncio.gather(
            self.py_client.cleanup(),
            self.ts_client.cleanup()
        )

    @pytest.mark.asyncio
    async def test_realtime_context_synchronization(self):
        # Python„Åß„É™„Ç¢„É´„Çø„Ç§„É†„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
        received_events = []

        def on_context_updated(event):
            received_events.append(event)

        await self.py_client.events.subscribe('context.updated', on_context_updated)

        # TypeScript„ÅßContext‰ΩúÊàê„Å®Êõ¥Êñ∞
        context_data = {
            'context_id': 'realtime-sync-test',
            'context_type': 'realtime_sync_test',
            'context_data': {
                'source_language': 'typescript',
                'target_language': 'python',
                'realtime': True
            },
            'created_by': 'typescript-client'
        }

        ts_context = await self.ts_client.context.create_context(context_data)
        assert ts_context['context_id'] == context_data['context_id']

        # ContextÊõ¥Êñ∞
        update_data = {
            'context_data': {
                **context_data['context_data'],
                'updated_at': '2025-09-04T12:00:00Z',
                'status': 'synchronized'
            }
        }

        await self.ts_client.context.update_context(
            context_data['context_id'],
            update_data
        )

        # Python„Åß„É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞Âèó‰ø°Á¢∫Ë™ç
        await asyncio.sleep(0.1)  # „Ç§„Éô„É≥„Éà‰ºùÊí≠ÂæÖÊ©ü
        assert len(received_events) == 1
        assert received_events[0]['context_id'] == context_data['context_id']
        assert received_events[0]['context_data']['status'] == 'synchronized'

    @pytest.mark.asyncio
    async def test_bidirectional_realtime_communication(self):
        # ÂèåÊñπÂêë„É™„Ç¢„É´„Çø„Ç§„É†ÈÄö‰ø°„ÉÜ„Çπ„Éà
        py_received = []
        ts_received = []

        # „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
        await self.py_client.events.subscribe(
            'custom.message',
            lambda event: py_received.append(event)
        )
        await self.ts_client.events.subscribe(
            'custom.message',
            lambda event: ts_received.append(event)
        )

        # Python„Åã„ÇâTypeScript„Å∏„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        await self.py_client.events.publish('custom.message', {
            'message_id': 'py-to-ts-msg',
            'content': 'Hello from Python!',
            'sender': 'python-client',
            'timestamp': '2025-09-04T12:00:00Z'
        })

        # TypeScript„Åã„ÇâPython„Å∏„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        await self.ts_client.events.publish('custom.message', {
            'message_id': 'ts-to-py-msg',
            'content': 'Hello from TypeScript!',
            'sender': 'typescript-client',
            'timestamp': '2025-09-04T12:00:01Z'
        })

        # ÂèåÊñπÂêëÈÄö‰ø°Á¢∫Ë™ç
        await asyncio.sleep(0.2)  # „Ç§„Éô„É≥„Éà‰ºùÊí≠ÂæÖÊ©ü

        assert len(py_received) == 1
        assert py_received[0]['content'] == 'Hello from TypeScript!'
        assert py_received[0]['sender'] == 'typescript-client'

        assert len(ts_received) == 1
        assert ts_received[0]['content'] == 'Hello from Python!'
        assert ts_received[0]['sender'] == 'python-client'
```

#### **Java ‚Üî Go Áõ∏‰∫íÈÅãÁî®ÊÄß**
```java
// Java-GoÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
@Test
public class JavaGoInteroperabilityTest {
    private MPLPClient javaClient;
    private GoMPLPClient goClient;

    @BeforeEach
    public void setUp() throws Exception {
        // Java„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        javaClient = new MPLPClient(MPLPConfig.builder()
            .language("java")
            .protocolVersion("1.0.0")
            .endpoint("http://localhost:3002")
            .build());

        // Go„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
        goClient = new GoMPLPClient(GoMPLPConfig.builder()
            .language("go")
            .protocolVersion("1.0.0")
            .endpoint("http://localhost:3003")
            .build());

        javaClient.initialize();
        goClient.initialize();
    }

    @AfterEach
    public void tearDown() throws Exception {
        javaClient.cleanup();
        goClient.cleanup();
    }

    @Test
    public void testJavaGoRoleInteroperability() throws Exception {
        // Java„ÅßRole‰ΩúÊàê
        RoleData roleData = RoleData.builder()
            .roleId("java-go-role-test")
            .roleType("cross_language_role")
            .roleData(Map.of(
                "sourceLanguage", "java",
                "targetLanguage", "go",
                "permissions", List.of("read", "write", "execute")
            ))
            .createdBy("java-client")
            .build();

        Role javaRole = javaClient.role().createRole(roleData);
        assertThat(javaRole.getRoleId()).isEqualTo(roleData.getRoleId());

        // Go„ÅßRoleÂèñÂæó„Å®Ê®©ÈôêÊ§úË®º
        Role goRole = goClient.role().getRole(roleData.getRoleId());
        assertThat(goRole.getRoleId()).isEqualTo(roleData.getRoleId());
        assertThat(goRole.getRoleType()).isEqualTo(roleData.getRoleType());

        // Ê®©ÈôêÊ§úË®º
        boolean hasPermission = goClient.role().checkPermission(
            roleData.getRoleId(), "execute"
        );
        assertThat(hasPermission).isTrue();
    }
}
```

---

## üîÑ „Éó„É≠„Éà„Ç≥„É´„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà

### **„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ**

#### **ÂæåÊñπ‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà**
```typescript
// ÂæåÊñπ‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
describe('MPLPÂæåÊñπ‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà', () => {
  const versionPairs = [
    { current: '1.0.0', previous: '1.0.0-alpha' },
    { current: '1.0.0', previous: '1.0.0-beta' },
    { current: '1.1.0', previous: '1.0.0' },
    { current: '1.1.0', previous: '1.0.0-beta' }
  ];

  versionPairs.forEach(({ current, previous }) => {
    describe(`„Éê„Éº„Ç∏„Éß„É≥ ${current} ‚Üí ${previous} ÂæåÊñπ‰∫íÊèõÊÄß`, () => {
      let currentClient: MPLPClient;
      let previousClient: MPLPClient;

      beforeEach(async () => {
        currentClient = new MPLPClient({ 
          protocolVersion: current 
        });
        previousClient = new MPLPClient({ 
          protocolVersion: previous 
        });

        await Promise.all([
          currentClient.initialize(),
          previousClient.initialize()
        ]);
      });

      afterEach(async () => {
        await Promise.all([
          currentClient.cleanup(),
          previousClient.cleanup()
        ]);
      });

      it('Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅåÂè§„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„Éá„Éº„Çø„ÇíË™≠„ÅøÂèñ„Çå„Çã', async () => {
        // Âè§„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„Åß„Éá„Éº„Çø‰ΩúÊàê
        const contextData = {
          contextId: `backward-compat-${previous}-${current}`,
          contextType: 'backward_compatibility_test',
          contextData: { 
            createdWithVersion: previous,
            testData: 'backward compatibility test data'
          },
          createdBy: `client-${previous}`
        };

        const oldContext = await previousClient.context.createContext(contextData);
        expect(oldContext.contextId).toBe(contextData.contextId);

        // Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„Åß„Éá„Éº„ÇøÂèñÂæó
        const newContext = await currentClient.context.getContext(contextData.contextId);
        expect(newContext.contextId).toBe(contextData.contextId);
        expect(newContext.contextType).toBe(contextData.contextType);
        expect(newContext.contextData.createdWithVersion).toBe(previous);
      });

      it('Âè§„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅåÊñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅÆÂü∫Êú¨„Éá„Éº„Çø„ÇíË™≠„ÅøÂèñ„Çå„Çã', async () => {
        // Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅßÂü∫Êú¨„Éá„Éº„Çø‰ΩúÊàêÔºàÂæåÊñπ‰∫íÊèõÊÄß„Çí‰øù„Å§Ôºâ
        const contextData = {
          contextId: `forward-compat-${current}-${previous}`,
          contextType: 'forward_compatibility_test',
          contextData: { 
            createdWithVersion: current,
            testData: 'forward compatibility test data'
          },
          createdBy: `client-${current}`
        };

        const newContext = await currentClient.context.createContext(contextData);
        expect(newContext.contextId).toBe(contextData.contextId);

        // Âè§„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„Åß„Éá„Éº„ÇøÂèñÂæó
        const oldContext = await previousClient.context.getContext(contextData.contextId);
        expect(oldContext.contextId).toBe(contextData.contextId);
        expect(oldContext.contextType).toBe(contextData.contextType);
      });
    });
  });
});
```

---

## üåç „Çµ„Éº„Éâ„Éë„Éº„ÉÜ„Ç£Áµ±Âêà„ÉÜ„Çπ„Éà

### **Â§ñÈÉ®„Ç∑„Çπ„ÉÜ„É†Áµ±Âêà**

#### **„Éá„Éº„Çø„Éô„Éº„ÇπÁµ±Âêà„ÉÜ„Çπ„Éà**
```typescript
// „Éá„Éº„Çø„Éô„Éº„ÇπÁµ±ÂêàÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
describe('„Éá„Éº„Çø„Éô„Éº„ÇπÁµ±ÂêàÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  const databases = [
    { type: 'postgresql', version: '13+', driver: 'pg' },
    { type: 'mysql', version: '8.0+', driver: 'mysql2' },
    { type: 'mongodb', version: '5.0+', driver: 'mongodb' },
    { type: 'redis', version: '6.0+', driver: 'redis' }
  ];

  databases.forEach(db => {
    describe(`${db.type} Áµ±Âêà`, () => {
      let mplpClient: MPLPClient;
      let dbConnection: any;

      beforeEach(async () => {
        mplpClient = new MPLPClient({
          database: {
            type: db.type,
            version: db.version,
            driver: db.driver
          }
        });

        dbConnection = await mplpClient.database.connect();
        await mplpClient.initialize();
      });

      afterEach(async () => {
        await mplpClient.cleanup();
        await dbConnection.close();
      });

      it(`${db.type}„ÅßMPLP„Éá„Éº„Çø„ÇíÊ∞∏Á∂öÂåñ„Åß„Åç„Çã`, async () => {
        // Context‰ΩúÊàê„Å®DB‰øùÂ≠ò
        const context = await mplpClient.context.createContext({
          contextId: `db-integration-${db.type}`,
          contextType: 'database_integration_test',
          contextData: { 
            databaseType: db.type,
            testTimestamp: new Date().toISOString()
          },
          createdBy: 'database-integration-test'
        });

        // „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„ÇâÁõ¥Êé•Ê§úË®º
        const dbResult = await dbConnection.query(
          'SELECT * FROM contexts WHERE context_id = ?',
          [context.contextId]
        );

        expect(dbResult.rows).toHaveLength(1);
        expect(dbResult.rows[0].context_id).toBe(context.contextId);
      });
    });
  });
});
```

#### **„É°„ÉÉ„Çª„Éº„Ç∏„Ç≠„É•„ÉºÁµ±Âêà„ÉÜ„Çπ„Éà**
```typescript
// „É°„ÉÉ„Çª„Éº„Ç∏„Ç≠„É•„ÉºÁµ±Âêà„ÉÜ„Çπ„Éà
describe('„É°„ÉÉ„Çª„Éº„Ç∏„Ç≠„É•„ÉºÁµ±ÂêàÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  const messageQueues = [
    { type: 'rabbitmq', version: '3.8+' },
    { type: 'apache-kafka', version: '2.8+' },
    { type: 'redis-streams', version: '6.0+' },
    { type: 'aws-sqs', version: 'latest' }
  ];

  messageQueues.forEach(mq => {
    describe(`${mq.type} Áµ±Âêà`, () => {
      let mplpClient: MPLPClient;
      let mqConnection: any;

      beforeEach(async () => {
        mplpClient = new MPLPClient({
          messageQueue: {
            type: mq.type,
            version: mq.version
          }
        });

        mqConnection = await mplpClient.messageQueue.connect();
        await mplpClient.initialize();
      });

      afterEach(async () => {
        await mplpClient.cleanup();
        await mqConnection.close();
      });

      it(`${mq.type}„ÅßMPLP„Ç§„Éô„É≥„Éà„ÇíÈÖç‰ø°„Åß„Åç„Çã`, async () => {
        const eventData = {
          eventId: `mq-integration-${mq.type}`,
          eventType: 'context.created',
          eventData: {
            contextId: 'test-context',
            messageQueueType: mq.type
          },
          timestamp: new Date().toISOString()
        };

        // „Ç§„Éô„É≥„ÉàÁô∫Ë°å
        await mplpClient.events.publish(eventData);

        // „É°„ÉÉ„Çª„Éº„Ç∏„Ç≠„É•„Éº„Åã„ÇâÂèó‰ø°Á¢∫Ë™ç
        const receivedMessage = await mqConnection.consume('mplp.events');
        expect(receivedMessage.eventId).toBe(eventData.eventId);
        expect(receivedMessage.eventType).toBe(eventData.eventType);
      });
    });
  });
});
```

---

## üîÑ „É™„Ç¢„É´„Çø„Ç§„É†ÈÄö‰ø°„ÉÜ„Çπ„Éà

### **WebSocketÁõ∏‰∫íÈÅãÁî®ÊÄß**

#### **„É™„Ç¢„É´„Çø„Ç§„É†„Ç§„Éô„É≥„ÉàÈÖç‰ø°„ÉÜ„Çπ„Éà**
```typescript
// WebSocketÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
describe('WebSocketÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  let wsServer: WebSocketServer;
  let wsClient1: WebSocketClient;
  let wsClient2: WebSocketClient;

  beforeAll(async () => {
    wsServer = new WebSocketServer({ port: 8080 });
    await wsServer.start();
  });

  afterAll(async () => {
    await wsServer.stop();
  });

  beforeEach(async () => {
    wsClient1 = new WebSocketClient('ws://localhost:8080');
    wsClient2 = new WebSocketClient('ws://localhost:8080');

    await Promise.all([
      wsClient1.connect(),
      wsClient2.connect()
    ]);
  });

  afterEach(async () => {
    await Promise.all([
      wsClient1.disconnect(),
      wsClient2.disconnect()
    ]);
  });

  it('Ë§áÊï∞„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÈñì„Åß„É™„Ç¢„É´„Çø„Ç§„É†„Ç§„Éô„É≥„Éà„ÇíÈÖç‰ø°„Åß„Åç„Çã', async () => {
    const eventPromise = new Promise((resolve) => {
      wsClient2.on('context.updated', resolve);
    });

    // „ÇØ„É©„Ç§„Ç¢„É≥„Éà1„Åã„Çâ„Ç§„Éô„É≥„ÉàÈÄÅ‰ø°
    await wsClient1.emit('context.update', {
      contextId: 'realtime-test-context',
      updateData: { status: 'updated' },
      timestamp: new Date().toISOString()
    });

    // „ÇØ„É©„Ç§„Ç¢„É≥„Éà2„Åß„Ç§„Éô„É≥„ÉàÂèó‰ø°Á¢∫Ë™ç
    const receivedEvent = await eventPromise;
    expect(receivedEvent.contextId).toBe('realtime-test-context');
    expect(receivedEvent.updateData.status).toBe('updated');
  });
});
```

### **gRPCÁõ∏‰∫íÈÅãÁî®ÊÄß**

#### **È´òÊÄßËÉΩÈÄö‰ø°„ÉÜ„Çπ„Éà**
```typescript
// gRPCÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà
describe('gRPCÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  let grpcServer: GRPCServer;
  let grpcClient: GRPCClient;

  beforeAll(async () => {
    grpcServer = new GRPCServer({
      port: 50051,
      protoPath: './proto/mplp.proto'
    });
    await grpcServer.start();
  });

  afterAll(async () => {
    await grpcServer.stop();
  });

  beforeEach(async () => {
    grpcClient = new GRPCClient({
      endpoint: 'localhost:50051',
      protoPath: './proto/mplp.proto'
    });
    await grpcClient.connect();
  });

  afterEach(async () => {
    await grpcClient.disconnect();
  });

  it('gRPC„ÅßMPLPÊìç‰Ωú„ÇíÈ´òÊÄßËÉΩÂÆüË°å„Åß„Åç„Çã', async () => {
    const startTime = Date.now();

    // Â§ßÈáè„ÅÆContext‰ΩúÊàê„ÉÜ„Çπ„Éà
    const contextPromises = Array.from({ length: 100 }, (_, i) => 
      grpcClient.context.createContext({
        contextId: `grpc-perf-test-${i}`,
        contextType: 'performance_test',
        contextData: { index: i },
        createdBy: 'grpc-performance-test'
      })
    );

    const contexts = await Promise.all(contextPromises);
    const endTime = Date.now();

    expect(contexts).toHaveLength(100);
    expect(endTime - startTime).toBeLessThan(5000); // 5Áßí‰ª•ÂÜÖ

    // ÂÖ®„Å¶„ÅÆContext„ÅåÊ≠£„Åó„Åè‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
    contexts.forEach((context, index) => {
      expect(context.contextId).toBe(`grpc-perf-test-${index}`);
      expect(context.contextType).toBe('performance_test');
    });
  });
});
```

---

## üîÑ „Éá„Éº„Çø„Éï„Ç©„Éº„Éû„ÉÉ„Éà‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà

### **„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥‰∫íÊèõÊÄß**

#### **JSON ‚Üî Protocol Buffers ‰∫íÊèõÊÄß**
```typescript
// „Éá„Éº„Çø„Éï„Ç©„Éº„Éû„ÉÉ„Éà‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà
describe('„Éá„Éº„Çø„Éï„Ç©„Éº„Éû„ÉÉ„Éà‰∫íÊèõÊÄß', () => {
  let jsonClient: MPLPClient;
  let protobufClient: MPLPClient;

  beforeEach(async () => {
    jsonClient = new MPLPClient({
      dataFormat: 'json',
      protocolVersion: '1.0.0'
    });

    protobufClient = new MPLPClient({
      dataFormat: 'protobuf',
      protocolVersion: '1.0.0'
    });

    await Promise.all([
      jsonClient.initialize(),
      protobufClient.initialize()
    ]);
  });

  afterEach(async () => {
    await Promise.all([
      jsonClient.cleanup(),
      protobufClient.cleanup()
    ]);
  });

  it('JSON„Åß‰ΩúÊàê„Åó„Åü„Éá„Éº„Çø„ÇíProtocol Buffers„ÅßË™≠„ÅøÂèñ„Çå„Çã', async () => {
    // JSON„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅßContext‰ΩúÊàê
    const contextData = {
      contextId: 'json-protobuf-test',
      contextType: 'format_compatibility_test',
      contextData: {
        sourceFormat: 'json',
        targetFormat: 'protobuf',
        complexData: {
          nested: { value: 42 },
          array: [1, 2, 3],
          boolean: true
        }
      },
      createdBy: 'json-client'
    };

    const jsonContext = await jsonClient.context.createContext(contextData);
    expect(jsonContext.contextId).toBe(contextData.contextId);

    // Protocol Buffers„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅßContextÂèñÂæó
    const protobufContext = await protobufClient.context.getContext(contextData.contextId);
    expect(protobufContext.contextId).toBe(contextData.contextId);
    expect(protobufContext.contextData.sourceFormat).toBe('json');
    expect(protobufContext.contextData.complexData.nested.value).toBe(42);
  });
});
```

---

## üß™ Áµ±Âêà„ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™

### **„Ç®„É≥„Éâ„ÉÑ„Éº„Ç®„É≥„ÉâÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà**

#### **„Éû„É´„ÉÅË®ÄË™û„Éª„Éû„É´„ÉÅ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†Áµ±Âêà„ÉÜ„Çπ„Éà**
```typescript
// ÂåÖÊã¨ÁöÑÁµ±Âêà„ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™
describe('„Ç®„É≥„Éâ„ÉÑ„Éº„Ç®„É≥„ÉâÁõ∏‰∫íÈÅãÁî®ÊÄß', () => {
  let tsClient: MPLPClient;    // TypeScript on Windows
  let pyClient: PythonClient;  // Python on Linux
  let javaClient: JavaClient;  // Java on macOS
  let goClient: GoClient;      // Go on Container

  beforeAll(async () => {
    // Áï∞„Å™„Çã„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„Åß„ÅÆË§áÊï∞Ë®ÄË™û„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
    tsClient = new MPLPClient({
      language: 'typescript',
      platform: 'windows',
      endpoint: 'http://windows-host:3000'
    });

    pyClient = new PythonClient({
      language: 'python',
      platform: 'linux',
      endpoint: 'http://linux-host:3001'
    });

    javaClient = new JavaClient({
      language: 'java',
      platform: 'macos',
      endpoint: 'http://macos-host:3002'
    });

    goClient = new GoClient({
      language: 'go',
      platform: 'container',
      endpoint: 'http://container-host:3003'
    });

    await Promise.all([
      tsClient.initialize(),
      pyClient.initialize(),
      javaClient.initialize(),
      goClient.initialize()
    ]);
  });

  afterAll(async () => {
    await Promise.all([
      tsClient.cleanup(),
      pyClient.cleanup(),
      javaClient.cleanup(),
      goClient.cleanup()
    ]);
  });

  it('Ë§áÈõë„Å™„Éû„É´„ÉÅË®ÄË™û„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÇíÂÆüË°å„Åß„Åç„Çã', async () => {
    // 1. TypeScript (Windows) „ÅßContext‰ΩúÊàê
    const context = await tsClient.context.createContext({
      contextId: 'multi-lang-workflow',
      contextType: 'cross_platform_workflow',
      contextData: { 
        workflow: 'multi-language-integration',
        platforms: ['windows', 'linux', 'macos', 'container']
      },
      createdBy: 'typescript-client'
    });

    // 2. Python (Linux) „ÅßPlan‰ΩúÊàê
    const plan = await pyClient.plan.createPlan({
      planId: 'multi-lang-plan',
      planType: 'cross_platform_plan',
      planData: {
        tasks: [
          { id: 'task1', assignedTo: 'typescript', platform: 'windows' },
          { id: 'task2', assignedTo: 'python', platform: 'linux' },
          { id: 'task3', assignedTo: 'java', platform: 'macos' },
          { id: 'task4', assignedTo: 'go', platform: 'container' }
        ]
      },
      contextId: context.contextId
    });

    // 3. Java (macOS) „ÅßRole‰ΩúÊàê„Å®Ê®©ÈôêË®≠ÂÆö
    const role = await javaClient.role.createRole({
      roleId: 'multi-lang-executor',
      roleType: 'cross_platform_executor',
      roleData: {
        permissions: ['execute', 'read', 'write'],
        platforms: ['windows', 'linux', 'macos', 'container']
      },
      contextId: context.contextId
    });

    // 4. Go (Container) „Åß„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÂÆüË°å
    const execution = await goClient.core.executeWorkflow({
      workflowId: 'multi-lang-workflow',
      planId: plan.planId,
      roleId: role.roleId,
      contextId: context.contextId
    });

    // 5. ÂÖ®„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅßÁµêÊûúÊ§úË®º
    const [tsResult, pyResult, javaResult, goResult] = await Promise.all([
      tsClient.trace.getExecutionTrace(execution.executionId),
      pyClient.trace.getExecutionTrace(execution.executionId),
      javaClient.trace.getExecutionTrace(execution.executionId),
      goClient.trace.getExecutionTrace(execution.executionId)
    ]);

    // ÂÖ®„Å¶„ÅÆÁµêÊûú„Åå‰∏ÄËá¥„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
    expect(tsResult.executionId).toBe(execution.executionId);
    expect(pyResult.executionId).toBe(execution.executionId);
    expect(javaResult.executionId).toBe(execution.executionId);
    expect(goResult.executionId).toBe(execution.executionId);

    expect(execution.success).toBe(true);
    expect(execution.completedTasks).toHaveLength(4);
  });
});
```

---

## üîÑ Á∂ôÁ∂öÁöÑÁµ±Âêà„ÉÜ„Çπ„Éà

### **CI/CD „Éë„Ç§„Éó„É©„Ç§„É≥Áµ±Âêà**

#### **GitHub Actions Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà**
```yaml
# .github/workflows/interoperability-test.yml
name: MPLP Interoperability Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # ÊØéÊó•ÂçàÂâç2ÊôÇ„Å´ÂÆüË°å

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.9'
  JAVA_VERSION: '11'
  GO_VERSION: '1.19'

jobs:
  cross-platform-test:
    name: Cross-Platform Interoperability
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16, 18, 20]
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run cross-platform tests
        run: npm run test:interop:platform
        env:
          CI: true
          PLATFORM: ${{ matrix.os }}
          NODE_VERSION: ${{ matrix.node-version }}

  multi-language-test:
    name: Multi-Language Interoperability
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: mplp_interop_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Install Node.js dependencies
        run: npm ci
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-interop.txt
      
      - name: Install Java dependencies
        run: ./gradlew build -x test
      
      - name: Install Go dependencies
        run: go mod download
      
      - name: Start test services
        run: docker-compose -f docker-compose.interop-test.yml up -d
      
      - name: Wait for services
        run: npm run wait-for-services
      
      - name: Run multi-language interoperability tests
        run: npm run test:interop:multilang
        env:
          CI: true
          DATABASE_URL: postgresql://postgres:test_password@localhost:5432/mplp_interop_test
          REDIS_URL: redis://localhost:6379
      
      - name: Cleanup test services
        if: always()
        run: docker-compose -f docker-compose.interop-test.yml down

  version-compatibility-test:
    name: Version Compatibility
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ['1.0.0-alpha', '1.0.0-beta', '1.0.0']
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run version compatibility tests
        run: npm run test:interop:version
        env:
          CI: true
          TARGET_VERSION: ${{ matrix.version }}
          CURRENT_VERSION: '1.0.0-alpha'

  third-party-integration-test:
    name: Third-Party Integration
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Start third-party services
        run: docker-compose -f docker-compose.third-party.yml up -d
      
      - name: Run third-party integration tests
        run: npm run test:interop:third-party
        env:
          CI: true
      
      - name: Cleanup third-party services
        if: always()
        run: docker-compose -f docker-compose.third-party.yml down

  performance-interop-test:
    name: Performance Interoperability
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || contains(github.event.head_commit.message, '[perf-interop]')
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run performance interoperability tests
        run: npm run test:interop:performance
        env:
          CI: true
          PERFORMANCE_TEST_DURATION: 300 # 5ÂàÜÈñì
          PERFORMANCE_TEST_CONCURRENCY: 50
      
      - name: Upload performance report
        uses: actions/upload-artifact@v3
        with:
          name: interop-performance-report
          path: reports/interop-performance/
```

---

## üîÑ „Éó„É≠„Éà„Ç≥„É´„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà

### **„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ**

#### **„Éó„É≠„Éà„Ç≥„É´„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà**
```typescript
// „Éó„É≠„Éà„Ç≥„É´„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
describe('MPLP„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà', () => {
  const versionMatrix = [
    { version: '1.0.0-alpha', compatible: ['1.0.0-alpha'] },
    { version: '1.0.0-beta', compatible: ['1.0.0-alpha', '1.0.0-beta'] },
    { version: '1.0.0', compatible: ['1.0.0-alpha', '1.0.0-beta', '1.0.0'] },
    { version: '1.1.0', compatible: ['1.0.0', '1.1.0'] }
  ];

  versionMatrix.forEach(currentVersion => {
    describe(`„Éê„Éº„Ç∏„Éß„É≥ ${currentVersion.version} ‰∫íÊèõÊÄß`, () => {
      currentVersion.compatible.forEach(compatibleVersion => {
        it(`„Éê„Éº„Ç∏„Éß„É≥ ${compatibleVersion} „Å®‰∫íÊèõÊÄß„Åå„ÅÇ„Çã`, async () => {
          const currentClient = new MPLPClient({ 
            protocolVersion: currentVersion.version 
          });
          const compatibleClient = new MPLPClient({ 
            protocolVersion: compatibleVersion 
          });

          // Âü∫Êú¨ÈÄö‰ø°„ÉÜ„Çπ„Éà
          const context = await currentClient.context.createContext({
            contextId: `ctx-version-test-${currentVersion.version}-${compatibleVersion}`,
            contextType: 'version_compatibility_test',
            contextData: { 
              currentVersion: currentVersion.version,
              compatibleVersion: compatibleVersion
            },
            createdBy: 'version-compatibility-test'
          });

          const retrievedContext = await compatibleClient.context.getContext(context.contextId);
          expect(retrievedContext.contextId).toBe(context.contextId);

          // „Éó„É≠„Éà„Ç≥„É´„Éç„Ç¥„Ç∑„Ç®„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà
          const negotiationResult = await currentClient.core.negotiateProtocolVersion(compatibleVersion);
          expect(negotiationResult.negotiated).toBe(true);
          expect(negotiationResult.agreedVersion).toBeDefined();
        });
      });
    });
  });
});
```

---

## üîó Èñ¢ÈÄ£„Éâ„Ç≠„É•„É°„É≥„Éà

- [„ÉÜ„Çπ„Éà„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØÊ¶ÇË¶Å](./README.md) - „ÉÜ„Çπ„Éà„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØÊ¶ÇË¶Å
- [„Éó„É≠„Éà„Ç≥„É´Ê∫ñÊã†„ÉÜ„Çπ„Éà](./protocol-compliance-testing.md) - L1-L3„Éó„É≠„Éà„Ç≥„É´Ê§úË®º
- [„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éô„É≥„ÉÅ„Éû„Éº„ÇØ](./performance-benchmarking.md) - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊ§úË®º
- [„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà](./security-testing.md) - „Çª„Ç≠„É•„É™„ÉÜ„Ç£Ê§úË®º
- [Â§öË®ÄË™û„Çµ„Éù„Éº„Éà](../implementation/multi-language-support.md) - Ë®ÄË™ûÂÆüË£Ö

---

**Áõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà„Éê„Éº„Ç∏„Éß„É≥**: 1.0.0-alpha  
**ÊúÄÁµÇÊõ¥Êñ∞**: 2025Âπ¥9Êúà4Êó•  
**Ê¨°Âõû„É¨„Éì„É•„Éº**: 2025Âπ¥12Êúà4Êó•  
**„Çπ„ÉÜ„Éº„Çø„Çπ**: „Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫Ê§úË®ºÊ∏à„Åø  

**‚ö†Ô∏è Alpha„ÅäÁü•„Çâ„Åõ**: „Åì„ÅÆÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà„Ç¨„Ç§„Éâ„ÅØ„ÄÅMPLP v1.0 Alpha„Å´ÂØæ„Åô„ÇãÂåÖÊã¨ÁöÑ„Å™„ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„Åä„Çà„Å≥Â§öË®ÄË™ûÊ§úË®º„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇÁµ±Âêà„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Å®„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„ÅÆÈÄ≤Âåñ„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅBeta„É™„É™„Éº„Çπ„ÅßËøΩÂä†„ÅÆÁõ∏‰∫íÈÅãÁî®ÊÄß„ÉÜ„Çπ„Éà„Å®‰∫íÊèõÊÄßÊ©üËÉΩ„ÅåËøΩÂä†„Åï„Çå„Çã‰∫àÂÆö„Åß„Åô„ÄÇ
