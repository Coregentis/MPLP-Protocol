import { UUID } from '../../../../shared/types';
import { IExtensionRepository, ExtensionQueryFilter, PaginationParams, SortParams, ExtensionQueryResult, BatchOperationResult, ExtensionStatistics } from '../../domain/repositories/extension.repository.interface';
import { ExtensionEntityData, ExtensionType, ExtensionStatus } from '../../types';
export declare class ExtensionRepository implements IExtensionRepository {
    private extensions;
    private nameIndex;
    private contextIndex;
    private typeIndex;
    private statusIndex;
    create(extension: ExtensionEntityData): Promise<ExtensionEntityData>;
    findById(extensionId: UUID): Promise<ExtensionEntityData | null>;
    update(extensionId: UUID, updates: Partial<ExtensionEntityData>): Promise<ExtensionEntityData>;
    delete(extensionId: UUID): Promise<boolean>;
    findByFilter(filter: ExtensionQueryFilter, pagination?: PaginationParams, sort?: SortParams[]): Promise<ExtensionQueryResult>;
    findByContextId(contextId: UUID): Promise<ExtensionEntityData[]>;
    findByType(extensionType: ExtensionType, status?: ExtensionStatus): Promise<ExtensionEntityData[]>;
    findByStatus(status: ExtensionStatus): Promise<ExtensionEntityData[]>;
    findAll(): Promise<ExtensionEntityData[]>;
    findByName(name: string, exactMatch?: boolean): Promise<ExtensionEntityData[]>;
    search(searchTerm: string, searchFields?: string[], pagination?: PaginationParams): Promise<ExtensionQueryResult>;
    count(filter?: ExtensionQueryFilter): Promise<number>;
    exists(extensionId: UUID): Promise<boolean>;
    nameExists(name: string, excludeId?: UUID): Promise<boolean>;
    getStatistics(filter?: ExtensionQueryFilter): Promise<ExtensionStatistics>;
    createBatch(extensions: ExtensionEntityData[]): Promise<BatchOperationResult>;
    updateBatch(updates: Array<{
        extensionId: UUID;
        updates: Partial<ExtensionEntityData>;
    }>): Promise<BatchOperationResult>;
    deleteBatch(extensionIds: UUID[]): Promise<BatchOperationResult>;
    updateStatusBatch(extensionIds: UUID[], status: ExtensionStatus): Promise<BatchOperationResult>;
    findActiveExtensions(contextId?: UUID): Promise<ExtensionEntityData[]>;
    findExtensionsWithErrors(contextId?: UUID): Promise<ExtensionEntityData[]>;
    findExtensionsNeedingUpdate(currentVersion: string): Promise<ExtensionEntityData[]>;
    findCompatibleExtensions(mplpVersion: string, requiredModules?: string[]): Promise<ExtensionEntityData[]>;
    findExtensionsWithExtensionPoint(extensionPointType: string): Promise<ExtensionEntityData[]>;
    findExtensionsWithApiExtensions(endpoint?: string, method?: string): Promise<ExtensionEntityData[]>;
    findExtensionsSubscribedToEvent(eventPattern: string): Promise<ExtensionEntityData[]>;
    updatePerformanceMetrics(extensionId: UUID, metrics: Partial<ExtensionEntityData['performanceMetrics']>): Promise<void>;
    findTopPerformingExtensions(limit?: number, metric?: 'responseTime' | 'throughput' | 'availability' | 'efficiencyScore'): Promise<ExtensionEntityData[]>;
    findRecentlyUpdatedExtensions(limit?: number, days?: number): Promise<ExtensionEntityData[]>;
    clear(): Promise<void>;
    cleanupExpiredAuditRecords(retentionDays: number): Promise<number>;
    optimize(): Promise<void>;
    private updateIndexes;
    private applyFilters;
    private applySorting;
    private getFieldValue;
    private calculateAverage;
    private getMetricValue;
    private isVersionOlder;
    private isVersionCompatible;
}
//# sourceMappingURL=extension.repository.d.ts.map