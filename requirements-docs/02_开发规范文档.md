# MPLP 1.0 开发规范文档
## Multi-Agent Project Lifecycle Protocol v1.0 Development Standards

> **文档版本**: v2.1  
> **创建日期**: 2025-07-09  
> **最后更新**: 2025-07-09T19:04:01+08:00  
> **开发负责人**: Coregentis 技术团队  
> **适用范围**: Multi-Agent Project Lifecycle Protocol (MPLP) v1.0 多智能体协作系统开发  
> **关联文档**: [技术设计文档](./01_技术设计文档.md), [产品需求文档](./09_产品需求文档.md), [MPLP协议开发专项路线图](./mplp_protocol_roadmap.md)  
> **开发周期**: 12周 (2025-07-09 至 2025-10-01)  
> **协议版本**: v1.0 (完全基于Roadmap v1.0规划)

---

## 📋 文档概述

### 规范目标
本文档定义MPLP 1.0项目的开发标准、代码规范、工作流程和质量要求，完全遵循[MPLP协议开发专项路线图 v1.0](./mplp_protocol_roadmap.md)中定义的5个开发阶段规划，确保多智能体协作系统开发过程的一致性和高质量。

### 核心目标
- 建立基于6个核心模块的标准化开发规范（匹配Roadmap第2阶段规划）
- 确保Context、Plan、Confirm、Trace、Role、Extension模块的一致性实现
- 支持跨平台、厂商中立的开发标准
- 为TracePilot、Coregentis等平台集成提供统一开发指导
- 建立覆盖完整生命周期的协议开发体系
- 严格执行Roadmap v1.0中定义的验收标准和交付物要求

### 适用原则
- **AI IDE优先**: 所有规范都考虑AI IDE的特点和能力
- **自动化优先**: 尽可能通过工具自动化执行规范
- **质量优先**: 代码质量和可维护性是首要考虑
- **效率优先**: 规范应该提高而不是降低开发效率
- **协议标准化**: 严格遵循JSON Schema和协议规范
- **模块化开发**: 支持独立模块开发和集成（符合Roadmap开发阶段设计）
- **性能优化**: 满足<10ms协议解析、P95<100ms API响应等Roadmap性能指标
- **安全第一**: 内置安全机制和最佳实践
- **厂商中立**: 避免绑定特定厂商或平台

---

## 🎯 MPLP开发标准概述

### 核心开发原则
1. **协议优先**: 严格遵循MPLP协议规范，确保6个核心模块的标准化实现
2. **类型安全**: 使用TypeScript严格模式，100%类型覆盖
3. **性能导向**: API响应时间P95 < 100ms，协议解析 < 10ms
4. **安全第一**: 所有API端点认证，敏感数据加密，完整审计
5. **测试驱动**: 单元测试覆盖率 ≥ 90%，集成测试覆盖核心流程
6. **文档同步**: 代码变更必须同步更新相关文档和Schema

### 技术栈统一标准
- **运行环境**: Node.js 18+ + TypeScript 5.0+
- **Web框架**: Express.js 4.18+ + Helmet.js (安全)
- **API层**: REST API + GraphQL + WebSocket
- **数据库**: PostgreSQL 14+ + TypeORM + Redis 7+
- **验证**: Ajv (JSON Schema) + Joi (数据验证)
- **测试**: Jest + Supertest + @testing-library
- **监控**: Prometheus + Winston Logger + Jaeger
- **构建**: TypeScript + ESBuild + Docker

## 🏗️ 项目结构规范

### 标准目录结构
```
mplp-v1/
├── src/                          # 源代码目录
│   ├── core/                     # 核心模块
│   │   ├── base-protocol.ts      # 协议基类
│   │   ├── validation-engine.ts  # 验证引擎
│   │   ├── protocol-engine.ts    # 协议引擎
│   │   ├── schema-validator.ts   # Schema验证器
│   │   ├── extension-manager.ts  # 扩展管理器
│   │   ├── state-manager.ts      # 状态管理器
│   │   ├── trace-collector.ts    # 追踪收集器
│   │   ├── security-manager.ts   # 安全管理器
│   │   └── adapter-framework.ts  # 适配器框架
│   ├── protocols/                # 协议模块 (6个核心模块)
│   │   ├── context/              # Context协议 - 全局状态管理
│   │   │   ├── context.protocol.ts
│   │   │   ├── context.handler.ts
│   │   │   ├── context.validator.ts
│   │   │   ├── context.service.ts
│   │   │   └── context.types.ts
│   │   ├── plan/                 # Plan协议 - 任务规划结构
│   │   │   ├── plan.protocol.ts
│   │   │   ├── plan.handler.ts
│   │   │   ├── plan.validator.ts
│   │   │   ├── plan.service.ts
│   │   │   └── plan.types.ts
│   │   ├── confirm/              # Confirm协议 - 验证决策机制
│   │   │   ├── confirm.protocol.ts
│   │   │   ├── confirm.handler.ts
│   │   │   ├── confirm.validator.ts
│   │   │   ├── confirm.service.ts
│   │   │   └── confirm.types.ts
│   │   ├── trace/                # Trace协议 - 追踪记录信息
│   │   │   ├── trace.protocol.ts
│   │   │   ├── trace.handler.ts
│   │   │   ├── trace.validator.ts
│   │   │   ├── trace.service.ts
│   │   │   └── trace.types.ts
│   │   ├── role/                 # Role协议 - 角色定义能力
│   │   │   ├── role.protocol.ts
│   │   │   ├── role.handler.ts
│   │   │   ├── role.validator.ts
│   │   │   ├── role.service.ts
│   │   │   └── role.types.ts
│   │   └── extension/            # Extension协议 - 扩展机制框架
│   │       ├── extension.protocol.ts
│   │       ├── extension.handler.ts
│   │       ├── extension.validator.ts
│   │       ├── extension.service.ts
│   │       ├── extension.manager.ts
│   │       └── extension.types.ts
│   ├── api/                      # API层
│   │   ├── rest/                 # REST API
│   │   │   ├── routes/           # 路由定义
│   │   │   ├── controllers/      # 控制器
│   │   │   ├── middleware/       # 中间件
│   │   │   └── validators/       # 请求验证
│   │   ├── graphql/              # GraphQL API
│   │   │   ├── schema/           # Schema定义
│   │   │   ├── resolvers/        # 解析器
│   │   │   └── subscriptions/    # 订阅
│   │   └── common/               # 公共API组件
│   ├── database/                 # 数据库层
│   │   ├── models/               # 数据模型
│   │   ├── repositories/         # 数据仓库
│   │   ├── migrations/           # 数据库迁移
│   │   └── seeds/                # 种子数据
│   ├── services/                 # 业务服务
│   │   ├── protocol-service.ts   # 协议服务
│   │   ├── execution-service.ts  # 执行服务
│   │   ├── trace-service.ts      # 追踪服务
│   │   └── auth-service.ts       # 认证服务
│   ├── adapters/                 # 平台适配器
│   │   ├── tracepilot/           # TracePilot适配器
│   │   ├── coregentis/           # Coregentis适配器
│   │   └── base/                 # 适配器基类
│   ├── utils/                    # 工具函数
│   │   ├── logger.ts             # 日志工具
│   │   ├── crypto.ts             # 加密工具
│   │   ├── validation.ts         # 验证工具
│   │   └── helpers.ts            # 辅助函数
│   ├── types/                    # 类型定义
│   │   ├── global.d.ts           # 全局类型
│   │   ├── api.types.ts          # API类型
│   │   └── protocol.types.ts     # 协议类型
│   ├── config/                   # 配置文件
│   │   ├── database.ts           # 数据库配置
│   │   ├── redis.ts              # Redis配置
│   │   ├── auth.ts               # 认证配置
│   │   └── app.ts                # 应用配置
│   └── index.ts                  # 应用入口
├── tests/                        # 测试目录
│   ├── unit/                     # 单元测试
│   ├── integration/              # 集成测试
│   ├── e2e/                      # 端到端测试
│   ├── fixtures/                 # 测试数据
│   ├── helpers/                  # 测试辅助
│   └── setup.ts                  # 测试配置
├── docs/                         # 文档目录
│   ├── api/                      # API文档
│   ├── protocols/                # 协议文档
│   ├── guides/                   # 使用指南
│   └── examples/                 # 示例代码
├── scripts/                      # 脚本目录
│   ├── build.ts                  # 构建脚本
│   ├── deploy.ts                 # 部署脚本
│   ├── migrate.ts                # 迁移脚本
│   └── seed.ts                   # 数据种子脚本
├── docker/                       # Docker配置
│   ├── Dockerfile                # 主Dockerfile
│   ├── docker-compose.yml        # 开发环境
│   └── docker-compose.prod.yml   # 生产环境
├── k8s/                          # Kubernetes配置
│   ├── deployment.yaml           # 部署配置
│   ├── service.yaml              # 服务配置
│   ├── ingress.yaml              # 入口配置
│   └── configmap.yaml            # 配置映射
├── .github/                      # GitHub配置
│   ├── workflows/                # CI/CD工作流
│   ├── ISSUE_TEMPLATE/           # Issue模板
│   └── PULL_REQUEST_TEMPLATE.md  # PR模板
├── package.json                  # 项目配置
├── tsconfig.json                 # TypeScript配置
├── jest.config.js                # Jest配置
├── .eslintrc.js                  # ESLint配置
├── .prettierrc                   # Prettier配置
├── .gitignore                    # Git忽略文件
├── README.md                     # 项目说明
└── CHANGELOG.md                  # 变更日志
```

### 文件命名规范

#### 1. 文件名格式
```typescript
// 6个核心模块文件命名
// Context模块
context.protocol.ts           // Context协议定义
context.handler.ts            // Context处理器
context.validator.ts          // Context验证器
context.service.ts            // Context服务
context.types.ts              // Context类型定义

// Plan模块
plan.protocol.ts              // Plan协议定义
plan.handler.ts               // Plan处理器
plan.validator.ts             // Plan验证器
plan.service.ts               // Plan服务
plan.types.ts                 // Plan类型定义

// Confirm模块
confirm.protocol.ts           // Confirm协议定义
confirm.handler.ts            // Confirm处理器
confirm.validator.ts          // Confirm验证器
confirm.service.ts            // Confirm服务
confirm.types.ts              // Confirm类型定义

// Trace模块
trace.protocol.ts             // Trace协议定义
trace.handler.ts              // Trace处理器
trace.validator.ts            // Trace验证器
trace.service.ts              // Trace服务
trace.types.ts                // Trace类型定义

// Role模块
role.protocol.ts              // Role协议定义
role.handler.ts               // Role处理器
role.validator.ts             // Role验证器
role.service.ts               // Role服务
role.types.ts                 // Role类型定义

// Extension模块
extension.protocol.ts         // Extension协议定义
extension.handler.ts          // Extension处理器
extension.validator.ts        // Extension验证器
extension.service.ts          // Extension服务
extension.manager.ts          // Extension管理器
extension.types.ts            // Extension类型定义

// 通用文件命名
{module-name}.repository.ts   // 数据仓库
{module-name}.controller.ts   // 控制器
{module-name}.middleware.ts   // 中间件

// 测试文件
{module-name}.test.ts         // 单元测试
{module-name}.integration.ts  // 集成测试
{module-name}.e2e.ts          // 端到端测试

// 配置文件
{config-name}.config.ts       // 配置文件
{env}.env                     // 环境变量
```

#### 2. 目录命名规范
- 使用小写字母和连字符
- 复数形式用于集合目录 (protocols, services, tests)
- 单数形式用于单一概念目录 (config, utils)
- 6个核心模块目录: context, plan, confirm, trace, role, extension
- 核心组件目录: core (包含protocol-engine, schema-validator等)
- 平台适配器目录: adapters (包含tracepilot, coregentis等)

---

## 💻 编码规范

### TypeScript编码标准

#### 1. 基础规范
```typescript
// ✅ 正确示例 - 基于6个核心模块

// Context模块接口定义
interface ContextProtocol {
  context_id: string;         // 使用snake_case匹配JSON Schema
  version: string;
  timestamp: string;
  status: 'active' | 'suspended' | 'terminated';
  lifecycle_stage: 'planning' | 'executing' | 'monitoring' | 'completed';
  shared_state: SharedState;  // 复合类型使用PascalCase
  access_control: AccessControl;
}

// Plan模块接口定义
interface PlanProtocol {
  plan_id: string;
  name: string;
  description?: string;
  tasks: Task[];
  workflow: WorkflowConfig;
  metadata: PlanMetadata;
}

// Confirm模块接口定义
interface ConfirmProtocol {
  confirm_id: string;
  target: ConfirmTarget;
  type: 'approval' | 'validation' | 'verification';
  criteria: ConfirmCriteria;
  approvers: Approver[];
  result?: ConfirmResult;
}

// Trace模块接口定义
interface TraceProtocol {
  trace_id: string;
  span_id: string;
  context_id: string;
  agent_id: string;
  action: TraceAction;
  timestamp: TraceTimestamp;
  result: TraceResult;
}

// Role模块接口定义
interface RoleProtocol {
  role_id: string;
  name: string;
  description?: string;
  capabilities: Capability[];
  permissions: Permission[];
  constraints: RoleConstraints;
}

// Extension模块接口定义
interface ExtensionProtocol {
  extension_id: string;
  name: string;
  version: string;
  type: 'plugin' | 'middleware' | 'adapter' | 'service';
  interface: ExtensionInterface;
  implementation: ExtensionImplementation;
  dependencies: ExtensionDependency[];
  security: ExtensionSecurity;
  metadata: ExtensionMetadata;
}

// 类定义 - 使用PascalCase
class ContextHandler {
  private readonly logger: Logger;  // 私有成员使用readonly
  private readonly validator: ContextValidator;
  
  constructor(logger: Logger, validator: ContextValidator) {
    this.logger = logger;
    this.validator = validator;
  }
  
  // 方法使用camelCase
  public async createContext(data: CreateContextRequest): Promise<ContextProtocol> {
    // 验证输入数据
    const validationResult = await this.validator.validate(data);
    if (!validationResult.valid) {
      throw new ValidationError('Invalid context data', validationResult.errors);
    }
    
    // 创建上下文
    const context: ContextProtocol = {
      context_id: generateUUID(),
      version: '1.0',
      timestamp: new Date().toISOString(),
      status: 'active',
      lifecycle_stage: 'planning',
      shared_state: data.shared_state || {},
      access_control: data.access_control || {}
    };
    
    this.logger.info('Context created', { context_id: context.context_id });
    return context;
  }
  
  public async updateContextStatus(
    contextId: string, 
    status: ContextProtocol['status'],
    reason?: string
  ): Promise<void> {
    // 实现状态更新逻辑
  }
}

// 枚举定义 - 使用PascalCase
enum ExecutionStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

// 常量定义 - 使用UPPER_SNAKE_CASE
const DEFAULT_TIMEOUT = 30000;
const MAX_RETRY_ATTEMPTS = 3;
const PROTOCOL_VERSION = '1.0';

// 类型别名 - 使用PascalCase
type ProtocolHandler<T> = (protocol: T) => Promise<ValidationResult>;
type EventCallback = (event: ProtocolEvent) => void;
```

#### 2. JSON Schema开发规范
```typescript
// ✅ Schema定义规范

// Schema文件结构
interface SchemaDefinition {
  $schema: string;           // 必须指定JSON Schema版本
  $id: string;              // 必须提供唯一标识符
  title: string;            // 必须提供标题
  description?: string;     // 推荐提供描述
  type: string;            // 必须指定类型
  properties?: object;      // 对象属性定义
  required?: string[];      // 必需字段列表
  additionalProperties?: boolean; // 是否允许额外属性
}

// Schema命名规范 - 基于6个核心模块
const SCHEMA_NAMING = {
  // 基础类型Schema
  baseTypes: 'base-types.json',
  
  // 6个核心模块Schema
  context: 'context.json',        // Context协议Schema
  plan: 'plan.json',              // Plan协议Schema
  confirm: 'confirm.json',        // Confirm协议Schema
  trace: 'trace.json',            // Trace协议Schema
  role: 'role.json',              // Role协议Schema
  extension: 'extension.json',    // Extension协议Schema
  
  // 复合Schema
  workflow: 'workflow.json',      // 工作流Schema
  security: 'security.json',      // 安全Schema
  metadata: 'metadata.json'       // 元数据Schema
};

// Schema引用规范
const schemaReference = {
  // 本地引用
  localRef: { "$ref": "#/definitions/uuid" },
  
  // 外部引用
  externalRef: { "$ref": "base-types.json#/definitions/timestamp" },
  
  // 远程引用
  remoteRef: { "$ref": "https://mplp.dev/schemas/v1.0/base-types.json#/definitions/uuid" }
};
```

#### 3. 验证机制开发规范
```typescript
// ✅ 验证器实现规范

// 基础验证器接口
interface BaseValidator<T> {
  validate(data: T): ValidationResult;
  validateAsync(data: T): Promise<ValidationResult>;
  getSchema(): JSONSchema;
}

// 验证结果标准格式
interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  metadata: {
    validatorName: string;
    validationTime: number;
    schemaVersion: string;
  };
}

// 错误信息标准格式
interface ValidationError {
  code: string;              // 错误代码
  message: string;           // 错误消息
  path: string;             // 错误路径
  value: any;               // 错误值
  severity: 'error' | 'warning' | 'info';
}

// 验证器实现示例 - 基于6个核心模块
class ContextValidator implements BaseValidator<ContextProtocol> {
  private schema: JSONSchema;
  private businessRules: BusinessRule[];
  
  constructor() {
    this.schema = this.loadSchema('context.json');
    this.businessRules = this.loadBusinessRules('context');
  }
  
  validate(data: ContextProtocol): ValidationResult {
    const schemaResult = this.validateSchema(data);
    const businessResult = this.validateBusinessRules(data);
    const securityResult = this.validateSecurity(data);
    
    return this.mergeResults([schemaResult, businessResult, securityResult]);
  }
  
  private validateSchema(data: ContextProtocol): ValidationResult {
    // JSON Schema验证
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(this.schema);
    const valid = validate(data);
    
    return {
      valid,
      errors: validate.errors?.map(err => ({
        code: 'SCHEMA_VALIDATION_ERROR',
        message: err.message || 'Schema validation failed',
        path: err.instancePath,
        value: err.data,
        severity: 'error' as const
      })) || [],
      warnings: [],
      metadata: {
        validatorName: 'ContextValidator',
        validationTime: Date.now(),
        schemaVersion: '1.0'
      }
    };
  }
  
  private validateBusinessRules(data: ContextProtocol): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    
    // 业务规则验证
    if (data.status === 'active' && !data.shared_state) {
      errors.push({
        code: 'MISSING_SHARED_STATE',
        message: 'Active context must have shared state',
        path: '/shared_state',
        value: data.shared_state,
        severity: 'error'
      });
    }
    
    // 生命周期阶段验证
    if (data.lifecycle_stage === 'completed' && data.status !== 'terminated') {
      warnings.push({
        code: 'LIFECYCLE_STATUS_MISMATCH',
        message: 'Completed lifecycle should have terminated status',
        path: '/status',
        value: data.status,
        severity: 'warning'
      });
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings,
      metadata: {
        validatorName: 'ContextValidator',
        validationTime: Date.now(),
        schemaVersion: '1.0'
      }
    };
  }
  
  private validateSecurity(data: ContextProtocol): ValidationResult {
    const errors: ValidationError[] = [];
    
    // 访问控制验证
    if (!data.access_control || !data.access_control.permissions) {
      errors.push({
        code: 'MISSING_ACCESS_CONTROL',
        message: 'Context must have access control configuration',
        path: '/access_control',
        value: data.access_control,
        severity: 'error'
      });
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings: [],
      metadata: {
        validatorName: 'ContextValidator',
        validationTime: Date.now(),
        schemaVersion: '1.0'
      }
    };
  }
}

// Plan模块验证器示例
class PlanValidator implements BaseValidator<PlanProtocol> {
  private schema: JSONSchema;
  
  constructor() {
    this.schema = this.loadSchema('plan.json');
  }
  
  validate(data: PlanProtocol): ValidationResult {
    // Plan特定的验证逻辑
    const errors: ValidationError[] = [];
    
    // 任务依赖验证
    if (data.tasks && data.tasks.length > 0) {
      const taskIds = new Set(data.tasks.map(t => t.task_id));
      
      for (const task of data.tasks) {
        if (task.dependencies) {
          for (const depId of task.dependencies) {
            if (!taskIds.has(depId)) {
              errors.push({
                code: 'INVALID_TASK_DEPENDENCY',
                message: `Task dependency '${depId}' not found in plan`,
                path: `/tasks/${task.task_id}/dependencies`,
                value: depId,
                severity: 'error'
              });
            }
          }
        }
      }
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings: [],
      metadata: {
        validatorName: 'PlanValidator',
        validationTime: Date.now(),
        schemaVersion: '1.0'
      }
    };
  }
}
```

#### 4. 性能监控开发规范
```typescript
// ✅ 性能监控实现规范

// 性能指标收集
class PerformanceCollector {
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  
  // 记录执行时间
  @measureTime('protocol.validation')
  async validateProtocol(protocol: ProtocolObject): Promise<ValidationResult> {
    // 验证逻辑
  }
  
  // 记录内存使用
  @measureMemory('protocol.parsing')
  parseProtocol(input: string): ProtocolObject {
    // 解析逻辑
  }
  
  // 记录自定义指标
  recordMetric(name: string, value: number, tags?: Record<string, string>): void {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: new Date().toISOString(),
      tags: tags || {}
    };
    
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(metric);
  }
}

// 性能装饰器
function measureTime(metricName: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const startTime = performance.now();
      try {
        const result = await method.apply(this, args);
        const endTime = performance.now();
        
        // 记录执行时间
        this.recordMetric(`${metricName}.duration`, endTime - startTime);
        
        return result;
      } catch (error) {
        const endTime = performance.now();
        
        // 记录错误和执行时间
        this.recordMetric(`${metricName}.duration`, endTime - startTime);
        this.recordMetric(`${metricName}.errors`, 1);
        
        throw error;
      }
    };
  };
}
const DEFAULT_TIMEOUT = 30000;
const MAX_RETRY_ATTEMPTS = 3;

// 类型别名 - 使用PascalCase
type ProtocolType = 'context' | 'plan' | 'execute' | 'trace';
type ValidationResult = {
  isValid: boolean;
  errors: ValidationError[];
};
```

#### 2. 函数和方法规范
```typescript
// ✅ 正确的函数定义

// 纯函数 - 优先使用
function validateProtocolSchema(data: unknown, schema: JSONSchema): ValidationResult {
  // 无副作用的验证逻辑
  return {
    isValid: true,
    errors: []
  };
}

// 异步函数 - 明确返回Promise类型
async function executeProtocol(
  protocol: ProtocolObject,
  context: ExecutionContext
): Promise<ExecutionResult> {
  try {
    // 异步执行逻辑
    const result = await performExecution(protocol, context);
    return result;
  } catch (error) {
    // 错误处理
    throw new ExecutionError('Protocol execution failed', { cause: error });
  }
}

// 高阶函数 - 使用泛型
function createValidator<T>(
  schema: JSONSchema
): (data: unknown) => data is T {
  return (data: unknown): data is T => {
    // 验证逻辑
    return validateSchema(data, schema).isValid;
  };
}

// 装饰器函数
function withLogging<T extends (...args: any[]) => any>(
  target: T
): T {
  return ((...args: any[]) => {
    console.log(`Calling ${target.name} with args:`, args);
    const result = target(...args);
    console.log(`${target.name} returned:`, result);
    return result;
  }) as T;
}
```

#### 3. 错误处理规范
```typescript
// ✅ 自定义错误类
class ProtocolError extends Error {
  public readonly code: string;
  public readonly details?: Record<string, any>;
  
  constructor(
    message: string,
    code: string,
    details?: Record<string, any>
  ) {
    super(message);
    this.name = 'ProtocolError';
    this.code = code;
    this.details = details;
  }
}

class ValidationError extends ProtocolError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

// ✅ 错误处理模式
async function safeExecuteProtocol(
  protocol: ProtocolObject
): Promise<Result<ExecutionResult, ProtocolError>> {
  try {
    const result = await executeProtocol(protocol);
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof ProtocolError) {
      return { success: false, error };
    }
    
    // 包装未知错误
    return {
      success: false,
      error: new ProtocolError(
        'Unexpected error during protocol execution',
        'UNKNOWN_ERROR',
        { originalError: error }
      )
    };
  }
}

// Result类型定义
type Result<T, E> = 
  | { success: true; data: T }
  | { success: false; error: E };
```

### 代码注释规范

#### 1. JSDoc注释
```typescript
/**
 * 创建新的协议上下文
 * 
 * @description 此方法创建一个新的MPLP协议上下文，用于管理多Agent系统的全局状态
 * @param data - 上下文创建请求数据
 * @param options - 可选的创建选项
 * @returns Promise<ContextProtocol> 创建的上下文协议对象
 * 
 * @throws {ValidationError} 当输入数据验证失败时抛出
 * @throws {DatabaseError} 当数据库操作失败时抛出
 * 
 * @example
 * ```typescript
 * const context = await createContext({
 *   projectId: 'proj-123',
 *   sessionId: 'sess-456',
 *   environment: 'development'
 * });
 * ```
 * 
 * @since 1.0.0
 * @author AI IDE Development Team
 */
async function createContext(
  data: CreateContextRequest,
  options?: CreateContextOptions
): Promise<ContextProtocol> {
  // 实现逻辑
}
```

#### 2. 内联注释
```typescript
function optimizePlan(plan: PlanProtocol): PlanProtocol {
  // 第一步：分析任务依赖关系
  const dependencyGraph = analyzeDependencies(plan.tasks);
  
  // 第二步：检测并解决循环依赖
  const circularDeps = detectCircularDependencies(dependencyGraph);
  if (circularDeps.length > 0) {
    throw new ValidationError('Circular dependencies detected', {
      dependencies: circularDeps
    });
  }
  
  // 第三步：优化任务执行顺序
  // 使用拓扑排序算法确定最优执行顺序
  const optimizedTasks = topologicalSort(plan.tasks, dependencyGraph);
  
  // 第四步：重新分配资源
  // 基于任务优先级和资源可用性进行资源分配
  const resourceAllocation = optimizeResourceAllocation(optimizedTasks);
  
  return {
    ...plan,
    tasks: optimizedTasks,
    resources: resourceAllocation
  };
}
```

#### 3. TODO和FIXME注释
```typescript
// TODO: [MPLP-123] 实现缓存机制以提高性能
// 预计完成时间: 2025-01-25
// 负责人: AI IDE Team
function getContextById(id: string): Promise<ContextProtocol> {
  // 当前直接查询数据库，后续需要添加缓存层
  return database.contexts.findById(id);
}

// FIXME: [MPLP-456] 修复并发访问时的竞态条件
// 优先级: High
// 发现时间: 2025-01-20
function updateContext(id: string, updates: Partial<ContextProtocol>): Promise<ContextProtocol> {
  // 当前实现存在竞态条件，需要添加乐观锁机制
  return database.contexts.update(id, updates);
}

// HACK: [MPLP-789] 临时解决方案，等待上游API修复
// 计划移除时间: 2025-02-01
function workaroundForUpstreamBug(data: any): any {
  // 临时处理上游API返回格式不一致的问题
  if (data.timestamp && typeof data.timestamp === 'number') {
    data.timestamp = new Date(data.timestamp).toISOString();
  }
  return data;
}
```

---

## 🔧 工具配置

### TypeScript配置 (tsconfig.json)
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noUncheckedIndexedAccess": true,
    "baseUrl": "./src",
    "paths": {
      "@core/*": ["core/*"],
      "@protocols/*": ["protocols/*"],
      "@api/*": ["api/*"],
      "@services/*": ["services/*"],
      "@utils/*": ["utils/*"],
      "@types/*": ["types/*"],
      "@config/*": ["config/*"]
    }
  },
  "include": [
    "src/**/*",
    "tests/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts"
  ]
}
```

### ESLint配置 (.eslintrc.js)
```javascript
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint',
    'import',
    'jest',
    'security',
    'sonarjs'
  ],
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    '@typescript-eslint/recommended-requiring-type-checking',
    'plugin:import/recommended',
    'plugin:import/typescript',
    'plugin:jest/recommended',
    'plugin:security/recommended',
    'plugin:sonarjs/recommended'
  ],
  rules: {
    // TypeScript规则
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'error',
    '@typescript-eslint/no-non-null-assertion': 'error',
    '@typescript-eslint/prefer-nullish-coalescing': 'error',
    '@typescript-eslint/prefer-optional-chain': 'error',
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/await-thenable': 'error',
    '@typescript-eslint/no-misused-promises': 'error',
    
    // 导入规则
    'import/order': [
      'error',
      {
        'groups': [
          'builtin',
          'external',
          'internal',
          'parent',
          'sibling',
          'index'
        ],
        'newlines-between': 'always',
        'alphabetize': {
          'order': 'asc',
          'caseInsensitive': true
        }
      }
    ],
    'import/no-unresolved': 'error',
    'import/no-cycle': 'error',
    
    // 代码质量规则
    'no-console': 'warn',
    'no-debugger': 'error',
    'no-alert': 'error',
    'prefer-const': 'error',
    'no-var': 'error',
    'object-shorthand': 'error',
    'prefer-template': 'error',
    
    // 安全规则
    'security/detect-object-injection': 'warn',
    'security/detect-non-literal-regexp': 'warn',
    
    // SonarJS规则
    'sonarjs/cognitive-complexity': ['error', 15],
    'sonarjs/no-duplicate-string': ['error', 3],
    'sonarjs/no-identical-functions': 'error'
  },
  settings: {
    'import/resolver': {
      typescript: {
        alwaysTryTypes: true,
        project: './tsconfig.json'
      }
    }
  },
  env: {
    node: true,
    jest: true,
    es2022: true
  }
};
```

### Prettier配置 (.prettierrc)
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "bracketSameLine": false,
  "arrowParens": "avoid",
  "endOfLine": "lf",
  "quoteProps": "as-needed",
  "jsxSingleQuote": true,
  "proseWrap": "preserve"
}
```

### Jest配置 (jest.config.js)
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  transform: {
    '^.+\.ts$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.test.ts',
    '!src/**/*.spec.ts'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: [
    'text',
    'lcov',
    'html',
    'json-summary'
  ],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  moduleNameMapping: {
    '^@core/(.*)$': '<rootDir>/src/core/$1',
    '^@protocols/(.*)$': '<rootDir>/src/protocols/$1',
    '^@api/(.*)$': '<rootDir>/src/api/$1',
    '^@services/(.*)$': '<rootDir>/src/services/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@types/(.*)$': '<rootDir>/src/types/$1',
    '^@config/(.*)$': '<rootDir>/src/config/$1'
  },
  testTimeout: 30000,
  verbose: true,
  detectOpenHandles: true,
  forceExit: true
};
```

---

## 🔄 Git工作流规范

### 分支策略

#### 1. 分支类型
```
main                    # 主分支，生产环境代码
├── develop            # 开发分支，集成最新功能
├── feature/*          # 功能分支
│   ├── feature/context-module
│   ├── feature/plan-module
│   └── feature/api-endpoints
├── bugfix/*           # 缺陷修复分支
│   ├── bugfix/validation-error
│   └── bugfix/memory-leak
├── hotfix/*           # 热修复分支
│   └── hotfix/security-patch
└── release/*          # 发布分支
    └── release/v1.0.0
```

#### 2. 分支命名规范
```bash
# 功能分支
feature/MPLP-123-context-module
feature/MPLP-456-rest-api

# 缺陷修复分支
bugfix/MPLP-789-validation-error
bugfix/MPLP-012-memory-leak

# 热修复分支
hotfix/MPLP-345-security-patch
hotfix/MPLP-678-critical-bug

# 发布分支
release/v1.0.0
release/v1.1.0
```

### 提交规范

#### 1. 提交消息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 2. 提交类型
```bash
feat:     # 新功能
fix:      # 缺陷修复
docs:     # 文档更新
style:    # 代码格式化
refactor: # 代码重构
perf:     # 性能优化
test:     # 测试相关
chore:    # 构建工具、依赖更新
ci:       # CI/CD配置
revert:   # 回滚提交
```

#### 3. 提交示例
```bash
# 功能提交
feat(context): implement context creation and validation

- Add ContextProtocol interface definition
- Implement ContextHandler with CRUD operations
- Add comprehensive validation rules
- Include unit tests with 95% coverage

Closes #MPLP-123

# 修复提交
fix(validation): resolve circular dependency detection

The previous implementation failed to detect complex circular
dependencies in task graphs. This fix implements a proper
depth-first search algorithm.

Fixes #MPLP-456
Tested-by: AI IDE Test Suite

# 文档提交
docs(api): update REST API documentation

- Add OpenAPI 3.0 specifications
- Include request/response examples
- Update authentication section

# 重构提交
refactor(core): extract common validation logic

Extracted shared validation patterns into reusable utilities
to reduce code duplication across protocol modules.

No functional changes.
```

### 代码审查规范

#### 1. Pull Request模板
```markdown
## 📋 变更描述

### 变更类型
- [ ] 新功能 (feature)
- [ ] 缺陷修复 (bugfix)
- [ ] 性能优化 (performance)
- [ ] 代码重构 (refactor)
- [ ] 文档更新 (docs)
- [ ] 测试改进 (test)

### 变更内容
<!-- 详细描述本次变更的内容和原因 -->

### 关联Issue
<!-- 关联的Issue编号，如: Closes #123, Fixes #456 -->

## 🧪 测试

### 测试覆盖
- [ ] 单元测试已添加/更新
- [ ] 集成测试已添加/更新
- [ ] 端到端测试已添加/更新
- [ ] 手动测试已完成

### 测试结果
<!-- 粘贴测试结果或截图 -->

## 📝 检查清单

### 代码质量
- [ ] 代码符合项目编码规范
- [ ] 所有ESLint规则通过
- [ ] 代码已通过Prettier格式化
- [ ] TypeScript类型检查通过
- [ ] 没有未使用的导入和变量

### 文档
- [ ] 代码注释完整且准确
- [ ] API文档已更新
- [ ] README已更新（如需要）
- [ ] CHANGELOG已更新

### 安全
- [ ] 没有硬编码的敏感信息
- [ ] 输入验证已实现
- [ ] 权限检查已实现
- [ ] 安全扫描通过

## 🚀 部署

### 部署影响
- [ ] 需要数据库迁移
- [ ] 需要配置更新
- [ ] 需要依赖更新
- [ ] 向后兼容

### 回滚计划
<!-- 如果部署失败，如何回滚 -->

## 📸 截图
<!-- 如果有UI变更，请提供截图 -->

## 🔗 相关链接
<!-- 相关的文档、设计稿、讨论链接等 -->
```

#### 2. 代码审查检查清单
```markdown
## 代码审查检查清单

### 🏗️ 架构和设计
- [ ] 代码结构清晰，符合项目架构
- [ ] 模块职责单一，耦合度低
- [ ] 接口设计合理，易于扩展
- [ ] 错误处理完善

### 💻 代码质量
- [ ] 代码逻辑正确，无明显bug
- [ ] 变量和函数命名清晰
- [ ] 代码复杂度合理
- [ ] 无重复代码
- [ ] 性能考虑充分

### 🧪 测试
- [ ] 测试覆盖率充足
- [ ] 测试用例有意义
- [ ] 边界条件已测试
- [ ] 异常情况已测试

### 🔒 安全
- [ ] 输入验证充分
- [ ] 权限检查正确
- [ ] 敏感数据处理安全
- [ ] SQL注入防护

### 📚 文档
- [ ] 代码注释充分
- [ ] API文档准确
- [ ] 复杂逻辑有说明
- [ ] 变更原因清楚
```

---

## 🧪 测试规范

### 测试策略

#### 1. 测试金字塔
```
        /\        E2E Tests (10%)
       /  \       - 端到端业务流程测试
      /____\      - 用户场景验证
     /      \     
    /        \    Integration Tests (20%)
   /          \   - API集成测试
  /____________\  - 数据库集成测试
 /              \ 
/________________\ Unit Tests (70%)
                   - 函数级别测试
                   - 类方法测试
                   - 模块测试
```

#### 2. 测试分类
```typescript
// 单元测试 - 测试单个函数或方法
describe('ContextValidator', () => {
  describe('validateContextSchema', () => {
    it('should return valid result for correct context data', () => {
      // 测试正确数据的验证
    });
    
    it('should return invalid result for missing required fields', () => {
      // 测试缺少必填字段的情况
    });
    
    it('should return invalid result for incorrect data types', () => {
      // 测试数据类型错误的情况
    });
  });
});

// 集成测试 - 测试模块间交互
describe('Context API Integration', () => {
  it('should create context and store in database', async () => {
    // 测试API端点与数据库的集成
  });
  
  it('should validate context and return appropriate errors', async () => {
    // 测试验证流程的集成
  });
});

// 端到端测试 - 测试完整业务流程
describe('Protocol Execution E2E', () => {
  it('should execute complete protocol workflow', async () => {
    // 测试从创建到执行的完整流程
  });
});
```

### 测试编写规范

#### 1. 测试文件结构
```typescript
// context.test.ts
import { ContextHandler } from '@protocols/context/context.handler';
import { createMockDatabase } from '@tests/helpers/mock-database';
import { createMockLogger } from '@tests/helpers/mock-logger';

// 测试数据
const VALID_CONTEXT_DATA = {
  projectId: 'test-project',
  sessionId: 'test-session',
  environment: 'test' as const
};

const INVALID_CONTEXT_DATA = {
  projectId: '',  // 无效：空字符串
  sessionId: 'test-session'
  // 缺少environment字段
};

describe('ContextHandler', () => {
  let contextHandler: ContextHandler;
  let mockDatabase: ReturnType<typeof createMockDatabase>;
  let mockLogger: ReturnType<typeof createMockLogger>;
  
  beforeEach(() => {
    mockDatabase = createMockDatabase();
    mockLogger = createMockLogger();
    contextHandler = new ContextHandler(mockDatabase, mockLogger);
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  describe('createContext', () => {
    it('should create context with valid data', async () => {
      // Arrange
      const expectedContext = {
        id: 'generated-id',
        ...VALID_CONTEXT_DATA,
        createdAt: expect.any(String)
      };
      
      mockDatabase.contexts.create.mockResolvedValue(expectedContext);
      
      // Act
      const result = await contextHandler.createContext(VALID_CONTEXT_DATA);
      
      // Assert
      expect(result).toEqual(expectedContext);
      expect(mockDatabase.contexts.create).toHaveBeenCalledWith(
        expect.objectContaining(VALID_CONTEXT_DATA)
      );
      expect(mockLogger.info).toHaveBeenCalledWith(
        'Context created successfully',
        { contextId: expectedContext.id }
      );
    });
    
    it('should throw ValidationError for invalid data', async () => {
      // Act & Assert
      await expect(
        contextHandler.createContext(INVALID_CONTEXT_DATA as any)
      ).rejects.toThrow(ValidationError);
      
      expect(mockDatabase.contexts.create).not.toHaveBeenCalled();
    });
    
    it('should handle database errors gracefully', async () => {
      // Arrange
      const databaseError = new Error('Database connection failed');
      mockDatabase.contexts.create.mockRejectedValue(databaseError);
      
      // Act & Assert
      await expect(
        contextHandler.createContext(VALID_CONTEXT_DATA)
      ).rejects.toThrow('Failed to create context');
      
      expect(mockLogger.error).toHaveBeenCalledWith(
        'Database error during context creation',
        { error: databaseError }
      );
    });
  });
});
```

#### 2. Mock和Stub规范
```typescript
// tests/helpers/mock-database.ts
export function createMockDatabase() {
  return {
    contexts: {
      create: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findByProjectId: jest.fn()
    },
    plans: {
      create: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn()
    },
    executions: {
      create: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByStatus: jest.fn()
    }
  };
}

// tests/helpers/mock-logger.ts
export function createMockLogger() {
  return {
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    fatal: jest.fn()
  };
}

// tests/fixtures/context-fixtures.ts
export const CONTEXT_FIXTURES = {
  valid: {
    minimal: {
      projectId: 'proj-123',
      sessionId: 'sess-456',
      environment: 'development' as const
    },
    complete: {
      projectId: 'proj-123',
      sessionId: 'sess-456',
      environment: 'development' as const,
      globalState: {
        variables: { key1: 'value1' },
        artifacts: [],
        knowledgeBase: []
      },
      metadata: {
        tags: ['test', 'development'],
        description: 'Test context'
      }
    }
  },
  invalid: {
    missingFields: {
      projectId: 'proj-123'
      // 缺少sessionId和environment
    },
    wrongTypes: {
      projectId: 123,  // 应该是string
      sessionId: 'sess-456',
      environment: 'invalid-env'  // 不在枚举值中
    }
  }
};
```

---

## 🚀 CI/CD规范

### GitHub Actions工作流

#### 1. 主工作流 (.github/workflows/main.yml)
```yaml
name: MPLP v1.0 CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 代码质量检查
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run ESLint
        run: npm run lint
        
      - name: Check Prettier formatting
        run: npm run format:check
        
      - name: TypeScript type check
        run: npm run type-check

  # 安全扫描
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run npm audit
        run: npm audit --audit-level=high
        
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  # 单元测试
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run unit tests
        run: npm run test:unit -- --coverage
        
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # 集成测试
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: mplp_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
          
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run database migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mplp_test
          
      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mplp_test
          REDIS_URL: redis://localhost:6379

  # 构建Docker镜像
  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [lint-and-format, security-scan, unit-tests, integration-tests]
    if: github.event_name != 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 部署到测试环境
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-image]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://mplp-staging.example.com
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment"
          # 实际的部署脚本

  # 部署到生产环境
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-image]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://mplp.example.com
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production environment"
          # 实际的部署脚本
```

#### 2. 发布工作流 (.github/workflows/release.yml)
```yaml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build project
        run: npm run build
        
      - name: Generate changelog
        id: changelog
        run: |
          npm run changelog
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat CHANGELOG.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
          
      - name: Publish to npm
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

---

## 📊 质量保证

### 代码质量指标

#### 1. 覆盖率要求
```javascript
// jest.config.js - 覆盖率阈值
coverageThreshold: {
  global: {
    branches: 90,      // 分支覆盖率 >= 90%
    functions: 90,     // 函数覆盖率 >= 90%
    lines: 90,         // 行覆盖率 >= 90%
    statements: 90     // 语句覆盖率 >= 90%
  },
  // 核心模块要求更高覆盖率
  'src/core/': {
    branches: 95,
    functions: 95,
    lines: 95,
    statements: 95
  }
}
```

#### 2. 代码复杂度控制
```javascript
// .eslintrc.js - 复杂度规则
rules: {
  'complexity': ['error', 10],                    // 圈复杂度 <= 10
  'max-depth': ['error', 4],                      // 嵌套深度 <= 4
  'max-lines': ['error', 300],                    // 文件行数 <= 300
  'max-lines-per-function': ['error', 50],        // 函数行数 <= 50
  'max-params': ['error', 4],                     // 参数个数 <= 4
  'sonarjs/cognitive-complexity': ['error', 15],  // 认知复杂度 <= 15
}
```

#### 3. 性能基准
```typescript
// tests/performance/benchmarks.test.ts
describe('Performance Benchmarks', () => {
  it('should parse protocol in less than 10ms', async () => {
    const startTime = performance.now();
    
    await protocolEngine.parse(LARGE_PROTOCOL_DATA);
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    expect(duration).toBeLessThan(10); // 10ms
  });
  
  it('should handle 1000 concurrent validations', async () => {
    const validations = Array(1000).fill(null).map(() => 
      validationEngine.validate(PROTOCOL_DATA)
    );
    
    const startTime = performance.now();
    await Promise.all(validations);
    const endTime = performance.now();
    
    const duration = endTime - startTime;
    expect(duration).toBeLessThan(1000); // 1秒内完成
  });
});
```

### 代码审查流程

#### 1. 自动化检查
```yaml
# .github/workflows/pr-checks.yml
name: PR Checks

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  automated-checks:
    name: Automated Code Review
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run all checks
        run: |
          npm run lint
          npm run type-check
          npm run test:unit
          npm run test:integration
          npm run security:scan
          
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          
      - name: Comment PR with results
        uses: actions/github-script@v6
        with:
          script: |
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });
            
            const failedChecks = checks.check_runs.filter(check => 
              check.status === 'completed' && check.conclusion === 'failure'
            );
            
            if (failedChecks.length > 0) {
              const comment = `## ❌ 自动化检查失败\n\n` +
                failedChecks.map(check => `- ${check.name}: ${check.conclusion}`).join('\n');
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
```

#### 2. 人工审查清单
```markdown
## 代码审查清单

### 🏗️ 架构设计
- [ ] 代码结构符合项目架构原则
- [ ] 模块职责清晰，耦合度合理
- [ ] 接口设计遵循SOLID原则
- [ ] 依赖注入使用正确

### 💻 代码实现
- [ ] 算法逻辑正确且高效
- [ ] 错误处理完善
- [ ] 边界条件考虑充分
- [ ] 资源管理正确（内存、连接等）

### 🧪 测试质量
- [ ] 测试覆盖率达标
- [ ] 测试用例有意义且充分
- [ ] Mock使用合理
- [ ] 集成测试覆盖关键路径

### 🔒 安全考虑
- [ ] 输入验证充分
- [ ] 权限检查正确
- [ ] 敏感数据处理安全
- [ ] 防止常见安全漏洞

### 📈 性能考虑
- [ ] 算法复杂度合理
- [ ] 数据库查询优化
- [ ] 缓存使用合理
- [ ] 内存使用效率

### 📚 文档质量
- [ ] 代码注释清晰准确
- [ ] API文档完整
- [ ] 复杂逻辑有详细说明
- [ ] 变更原因明确
```

---

## 📋 AI IDE开发检查清单

### 开发前准备
- [ ] 开发环境配置完成
- [ ] 依赖包安装完成
- [ ] 数据库连接测试通过
- [ ] 代码质量工具配置完成
- [ ] 测试环境准备就绪

### 开发过程检查
- [ ] 代码符合编码规范
- [ ] TypeScript类型定义完整
- [ ] 单元测试编写完成
- [ ] 集成测试编写完成
- [ ] 代码注释充分
- [ ] 错误处理完善
- [ ] 性能考虑充分
- [ ] 安全检查通过

### 提交前检查
- [ ] 所有测试通过
- [ ] 代码覆盖率达标
- [ ] ESLint检查通过
- [ ] TypeScript编译通过
- [ ] 安全扫描通过
- [ ] 性能基准测试通过
- [ ] 文档更新完成
- [ ] 变更日志更新

### 部署前检查
- [ ] 构建成功
- [ ] 容器镜像构建成功
- [ ] 环境配置正确
- [ ] 数据库迁移脚本准备
- [ ] 回滚计划制定
- [ ] 监控配置完成

---

## 📚 参考资源

### 编码规范参考
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)
- [Clean Code JavaScript](https://github.com/ryanmcdermott/clean-code-javascript)
- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)

### 测试最佳实践
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
- [Test Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

### Git工作流参考
- [Git Flow](https://nvie.com/posts/a-successful-git-branching-model/)
- [GitHub Flow](https://guides.github.com/introduction/flow/)
- [Conventional Commits](https://www.conventionalcommits.org/)

### 安全最佳实践
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)
- [npm Security Best Practices](https://docs.npmjs.com/security)

---

## 🤖 AI IDE工作串行顺序

### Phase 1: 项目初始化 (1-2天)

#### 1.1 环境搭建
```bash
# 1. 创建项目目录结构
mkdir -p mplp-v1/{src,tests,docs,scripts,docker,k8s}

# 2. 初始化Node.js项目
npm init -y

# 3. 安装核心依赖
npm install typescript @types/node
npm install express fastify
npm install ajv json-schema
npm install prisma @prisma/client
npm install redis ioredis
npm install winston

# 4. 安装开发依赖
npm install -D jest @types/jest ts-jest
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier
npm install -D nodemon ts-node
npm install -D supertest @types/supertest
```

#### 1.2 配置文件创建
- [ ] `tsconfig.json` - TypeScript配置
- [ ] `.eslintrc.js` - ESLint配置
- [ ] `.prettierrc` - Prettier配置
- [ ] `jest.config.js` - Jest测试配置
- [ ] `package.json` - 项目脚本配置
- [ ] `.gitignore` - Git忽略文件
- [ ] `docker-compose.yml` - 开发环境

### Phase 2: 核心架构实现 (3-5天)

#### 2.1 基础类型定义
```typescript
// 优先级: P0 - 必须首先完成
// 文件: src/types/global.d.ts
// 文件: src/types/protocol.types.ts
// 文件: src/types/api.types.ts
```

#### 2.2 核心引擎实现
```typescript
// 优先级: P0 - 核心功能
// 顺序: 按依赖关系实现

// 1. 基础协议类
src/core/base-protocol.ts

// 2. 验证引擎
src/core/validation-engine.ts

// 3. 协议引擎
src/core/protocol-engine.ts

// 4. 适配器框架
src/core/adapter-framework.ts
```

#### 2.3 工具函数实现
```typescript
// 优先级: P1 - 支撑功能
src/utils/logger.ts
src/utils/crypto.ts
src/utils/validation.ts
src/utils/helpers.ts
```

### Phase 3: 协议模块实现 (5-8天)

#### 3.1 Context协议 (Day 1)
```typescript
// 实现顺序:
// 1. 类型定义
src/protocols/context/context.types.ts

// 2. 协议定义
src/protocols/context/context.protocol.ts

// 3. 验证器
src/protocols/context/context.validator.ts

// 4. 处理器
src/protocols/context/context.handler.ts

// 5. 单元测试
tests/unit/protocols/context/
```

#### 3.2 Plan协议 (Day 2)
```typescript
// 依赖: Context协议
src/protocols/plan/plan.types.ts
src/protocols/plan/plan.protocol.ts
src/protocols/plan/plan.validator.ts
src/protocols/plan/plan.handler.ts
tests/unit/protocols/plan/
```

#### 3.3 Execute协议 (Day 3)
```typescript
// 依赖: Context + Plan协议
src/protocols/execute/execute.types.ts
src/protocols/execute/execute.protocol.ts
src/protocols/execute/execute.validator.ts
src/protocols/execute/execute.handler.ts
tests/unit/protocols/execute/
```

#### 3.4 其他协议 (Day 4-5)
```typescript
// 并行实现:
src/protocols/confirm/
src/protocols/learn/
src/protocols/trace/
src/protocols/test/
src/protocols/role/
src/protocols/workflow/
src/protocols/delivery/
```

### Phase 4: API层实现 (3-4天)

#### 4.1 REST API (Day 1-2)
```typescript
// 实现顺序:
// 1. 中间件
src/api/rest/middleware/auth.middleware.ts
src/api/rest/middleware/validation.middleware.ts
src/api/rest/middleware/error.middleware.ts
src/api/rest/middleware/logging.middleware.ts

// 2. 验证器
src/api/rest/validators/context.validator.ts
src/api/rest/validators/plan.validator.ts
src/api/rest/validators/execute.validator.ts

// 3. 控制器
src/api/rest/controllers/context.controller.ts
src/api/rest/controllers/plan.controller.ts
src/api/rest/controllers/execute.controller.ts

// 4. 路由
src/api/rest/routes/context.routes.ts
src/api/rest/routes/plan.routes.ts
src/api/rest/routes/execute.routes.ts
src/api/rest/routes/index.ts
```

#### 4.2 GraphQL API (Day 3-4)
```typescript
// 实现顺序:
// 1. Schema定义
src/api/graphql/schema/context.schema.ts
src/api/graphql/schema/plan.schema.ts
src/api/graphql/schema/execute.schema.ts
src/api/graphql/schema/index.ts

// 2. 解析器
src/api/graphql/resolvers/context.resolver.ts
src/api/graphql/resolvers/plan.resolver.ts
src/api/graphql/resolvers/execute.resolver.ts

// 3. 订阅
src/api/graphql/subscriptions/execution.subscription.ts
src/api/graphql/subscriptions/trace.subscription.ts
```

### Phase 5: 数据层实现 (2-3天)

#### 5.1 数据库设计 (Day 1)
```sql
-- 实现顺序:
-- 1. 数据库Schema设计
database/schema.sql

-- 2. Prisma Schema
prisma/schema.prisma

-- 3. 迁移文件
prisma/migrations/
```

#### 5.2 数据模型和仓库 (Day 2-3)
```typescript
// 实现顺序:
// 1. 数据模型
src/database/models/context.model.ts
src/database/models/plan.model.ts
src/database/models/execution.model.ts
src/database/models/trace.model.ts

// 2. 数据仓库
src/database/repositories/context.repository.ts
src/database/repositories/plan.repository.ts
src/database/repositories/execution.repository.ts
src/database/repositories/trace.repository.ts

// 3. 数据库连接
src/database/connection.ts
src/database/index.ts
```

### Phase 6: 业务服务实现 (2-3天)

#### 6.1 核心服务 (Day 1-2)
```typescript
// 实现顺序:
src/services/protocol-service.ts
src/services/execution-service.ts
src/services/trace-service.ts
src/services/auth-service.ts
```

#### 6.2 平台适配器 (Day 3)
```typescript
// 实现顺序:
src/adapters/base/base-adapter.ts
src/adapters/tracepilot/tracepilot-adapter.ts
src/adapters/coregentis/coregentis-adapter.ts
```

### Phase 7: 集成测试 (2-3天)

#### 7.1 API集成测试
```typescript
// 实现顺序:
tests/integration/api/rest/
tests/integration/api/graphql/
tests/integration/database/
tests/integration/services/
```

#### 7.2 端到端测试
```typescript
// 实现顺序:
tests/e2e/protocol-workflow.e2e.ts
tests/e2e/api-endpoints.e2e.ts
tests/e2e/adapter-integration.e2e.ts
```

### Phase 8: 配置和部署 (1-2天)

#### 8.1 配置管理
```typescript
// 实现顺序:
src/config/database.ts
src/config/redis.ts
src/config/auth.ts
src/config/app.ts
src/config/index.ts
```

#### 8.2 容器化和部署
```dockerfile
# 实现顺序:
docker/Dockerfile
docker/docker-compose.yml
docker/docker-compose.prod.yml
k8s/deployment.yaml
k8s/service.yaml
k8s/ingress.yaml
```

### Phase 9: 文档和示例 (1-2天)

#### 9.1 API文档
```markdown
# 实现顺序:
docs/api/rest-api.md
docs/api/graphql-api.md
docs/api/openapi.yaml
```

#### 9.2 使用指南和示例
```markdown
# 实现顺序:
docs/guides/quick-start.md
docs/guides/integration-guide.md
docs/examples/basic-usage.ts
docs/examples/advanced-usage.ts
```

---

## 📝 开发检查清单模板

### 每日开发检查
```markdown
## 日期: YYYY-MM-DD

### 今日目标
- [ ] 目标1
- [ ] 目标2
- [ ] 目标3

### 完成情况
- [x] 已完成任务1
- [x] 已完成任务2
- [ ] 进行中任务3 (50%)

### 代码质量检查
- [ ] ESLint检查通过
- [ ] TypeScript编译通过
- [ ] 单元测试通过
- [ ] 代码覆盖率 >= 90%

### 遇到的问题
1. 问题描述
   - 解决方案
   - 状态: 已解决/进行中/待解决

### 明日计划
- [ ] 计划任务1
- [ ] 计划任务2
```

### 模块完成检查
```markdown
## 模块: {模块名称}

### 实现完成度
- [ ] 类型定义 (100%)
- [ ] 核心逻辑 (100%)
- [ ] 错误处理 (100%)
- [ ] 单元测试 (100%)
- [ ] 集成测试 (100%)
- [ ] 文档更新 (100%)

### 质量指标
- [ ] 代码覆盖率 >= 90%
- [ ] 圈复杂度 <= 10
- [ ] 性能基准达标
- [ ] 安全扫描通过

### 依赖检查
- [ ] 上游依赖已完成
- [ ] 下游模块可以开始
- [ ] 接口契约已确定
```

---

## 📞 联系信息

**开发团队**: AI IDE Development Team  
**项目负责人**: AI IDE  
**技术支持**: 通过GitHub Issues  
**文档维护**: 开发团队  

---

## 🎯 代码规范最佳实践补充

### 高级TypeScript模式

#### 1. 类型安全的事件系统
```typescript
// ✅ 类型安全的事件发射器
interface EventMap {
  'protocol:created': { protocolId: string; type: string };
  'protocol:executed': { protocolId: string; result: ExecutionResult };
  'protocol:failed': { protocolId: string; error: Error };
}

class TypedEventEmitter<T extends Record<string, any>> {
  private listeners: {
    [K in keyof T]?: Array<(data: T[K]) => void>
  } = {};

  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }
}

// 使用示例
const protocolEvents = new TypedEventEmitter<EventMap>();

// ✅ 类型安全
protocolEvents.on('protocol:created', (data) => {
  console.log(`Protocol ${data.protocolId} of type ${data.type} created`);
});

// ❌ 编译时错误
// protocolEvents.on('invalid:event', (data) => {});
```

#### 2. 函数式编程模式
```typescript
// ✅ 函数式管道操作
type PipeFunction<T, R> = (input: T) => R;

function pipe<T>(...functions: Array<PipeFunction<any, any>>) {
  return (input: T) => functions.reduce((acc, fn) => fn(acc), input);
}

// 协议处理管道
const processProtocol = pipe(
  validateProtocolSchema,
  enrichWithContext,
  optimizeExecution,
  executeProtocol,
  recordTrace
);

// ✅ 函数式错误处理
type Either<L, R> = Left<L> | Right<R>;

class Left<L> {
  constructor(public readonly value: L) {}
  isLeft(): this is Left<L> { return true; }
  isRight(): this is Right<never> { return false; }
}

class Right<R> {
  constructor(public readonly value: R) {}
  isLeft(): this is Left<never> { return false; }
  isRight(): this is Right<R> { return true; }
}

function safeParseProtocol(input: string): Either<ValidationError, ProtocolObject> {
  try {
    const parsed = JSON.parse(input);
    const validation = validateProtocol(parsed);
    
    if (validation.isValid) {
      return new Right(parsed);
    } else {
      return new Left(new ValidationError('Invalid protocol', validation.errors));
    }
  } catch (error) {
    return new Left(new ValidationError('Parse error', [error]));
  }
}
```

#### 3. 装饰器模式进阶
```typescript
// ✅ 性能监控装饰器
function Monitor(metricName: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now();
      const startMemory = process.memoryUsage().heapUsed;
      
      try {
        const result = await method.apply(this, args);
        
        // 记录成功指标
        MetricsCollector.record({
          name: `${metricName}.success`,
          duration: Date.now() - startTime,
          memoryDelta: process.memoryUsage().heapUsed - startMemory,
          timestamp: new Date().toISOString()
        });
        
        return result;
      } catch (error) {
        // 记录失败指标
        MetricsCollector.record({
          name: `${metricName}.error`,
          duration: Date.now() - startTime,
          error: error.message,
          timestamp: new Date().toISOString()
        });
        
        throw error;
      }
    };
  };
}

// ✅ 缓存装饰器
function Cache(ttl: number = 300000) { // 5分钟默认TTL
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    const cache = new Map<string, { value: any; expiry: number }>();
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = JSON.stringify(args);
      const cached = cache.get(cacheKey);
      
      if (cached && cached.expiry > Date.now()) {
        return cached.value;
      }
      
      const result = await method.apply(this, args);
      cache.set(cacheKey, {
        value: result,
        expiry: Date.now() + ttl
      });
      
      return result;
    };
  };
}

// 使用示例
class ProtocolService {
  @Monitor('protocol.validation')
  @Cache(600000) // 10分钟缓存
  async validateProtocol(protocol: ProtocolObject): Promise<ValidationResult> {
    // 验证逻辑
  }
}
```

### 反模式和常见错误

#### 1. 避免的反模式
```typescript
// ❌ 反模式：过度使用any
function processData(data: any): any {
  return data.someProperty.doSomething();
}

// ✅ 正确：使用泛型和约束
interface Processable {
  someProperty: {
    doSomething(): unknown;
  };
}

function processData<T extends Processable>(data: T): ReturnType<T['someProperty']['doSomething']> {
  return data.someProperty.doSomething();
}

// ❌ 反模式：忽略错误处理
async function executeProtocol(protocol: ProtocolObject) {
  const result = await apiCall(protocol);
  return result.data;
}

// ✅ 正确：完善的错误处理
async function executeProtocol(protocol: ProtocolObject): Promise<ExecutionResult> {
  try {
    const result = await apiCall(protocol);
    
    if (!result.success) {
      throw new ExecutionError(`API call failed: ${result.error}`);
    }
    
    return result.data;
  } catch (error) {
    if (error instanceof ExecutionError) {
      throw error;
    }
    
    throw new ExecutionError('Unexpected error during protocol execution', {
      originalError: error,
      protocol: protocol.id
    });
  }
}

// ❌ 反模式：阻塞式同步操作
function loadConfiguration(): Config {
  const data = fs.readFileSync('config.json', 'utf8');
  return JSON.parse(data);
}

// ✅ 正确：异步操作
async function loadConfiguration(): Promise<Config> {
  try {
    const data = await fs.promises.readFile('config.json', 'utf8');
    return JSON.parse(data);
  } catch (error) {
    throw new ConfigurationError('Failed to load configuration', { cause: error });
  }
}
```

#### 2. 内存泄漏预防
```typescript
// ✅ 正确的事件监听器管理
class ProtocolManager {
  private eventListeners: Map<string, Function[]> = new Map();
  private timers: Set<NodeJS.Timeout> = new Set();
  private abortControllers: Set<AbortController> = new Set();
  
  addListener(event: string, listener: Function): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event)!.push(listener);
  }
  
  async executeWithTimeout(protocol: ProtocolObject, timeout: number): Promise<ExecutionResult> {
    const abortController = new AbortController();
    this.abortControllers.add(abortController);
    
    const timer = setTimeout(() => {
      abortController.abort();
    }, timeout);
    this.timers.add(timer);
    
    try {
      const result = await this.execute(protocol, { signal: abortController.signal });
      return result;
    } finally {
      clearTimeout(timer);
      this.timers.delete(timer);
      this.abortControllers.delete(abortController);
    }
  }
  
  // 清理资源
  dispose(): void {
    // 清理事件监听器
    this.eventListeners.clear();
    
    // 清理定时器
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
    
    // 取消所有进行中的操作
    this.abortControllers.forEach(controller => controller.abort());
    this.abortControllers.clear();
  }
}
```

---

## 🛠️ 高级工具链配置

### 开发环境增强

#### 1. VS Code配置优化
```json
// .vscode/settings.json
{
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
    "source.organizeImports": true
  },
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "files.associations": {
    "*.json": "jsonc"
  },
  "emmet.includeLanguages": {
    "typescript": "html"
  },
  "typescript.preferences.importModuleSpecifier": "relative",
  "search.exclude": {
    "**/node_modules": true,
    "**/dist": true,
    "**/coverage": true
  }
}

// .vscode/extensions.json
{
  "recommendations": [
    "ms-vscode.vscode-typescript-next",
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-json",
    "redhat.vscode-yaml",
    "ms-vscode-remote.remote-containers",
    "github.copilot",
    "github.copilot-chat"
  ]
}

// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug MPLP Server",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/src/index.ts",
      "outFiles": ["${workspaceFolder}/dist/**/*.js"],
      "runtimeArgs": ["-r", "ts-node/register"],
      "env": {
        "NODE_ENV": "development"
      },
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "name": "Debug Jest Tests",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["--runInBand", "--no-cache"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

#### 2. 高级Webpack配置
```javascript
// webpack.config.js
const path = require('path');
const nodeExternals = require('webpack-node-externals');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

module.exports = {
  entry: './src/index.ts',
  target: 'node',
  externals: [nodeExternals()],
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              transpileOnly: true,
              experimentalWatchApi: true,
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new CleanWebpackPlugin(),
    new ForkTsCheckerWebpackPlugin({
      eslint: {
        files: './src/**/*.{ts,tsx,js,jsx}',
      },
    }),
  ],
  resolve: {
    extensions: ['.ts', '.js'],
    alias: {
      '@core': path.resolve(__dirname, 'src/core'),
      '@protocols': path.resolve(__dirname, 'src/protocols'),
      '@api': path.resolve(__dirname, 'src/api'),
      '@services': path.resolve(__dirname, 'src/services'),
      '@utils': path.resolve(__dirname, 'src/utils'),
      '@types': path.resolve(__dirname, 'src/types'),
      '@config': path.resolve(__dirname, 'src/config'),
    },
  },
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    minimize: false,
  },
  devtool: 'source-map',
};
```

#### 3. 高级监控和分析工具
```typescript
// src/utils/performance-monitor.ts
import { performance, PerformanceObserver } from 'perf_hooks';

class PerformanceMonitor {
  private observer: PerformanceObserver;
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  
  constructor() {
    this.observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        this.recordMetric({
          name: entry.name,
          duration: entry.duration,
          startTime: entry.startTime,
          type: entry.entryType,
          timestamp: new Date().toISOString()
        });
      });
    });
    
    this.observer.observe({ entryTypes: ['measure', 'mark'] });
  }
  
  mark(name: string): void {
    performance.mark(name);
  }
  
  measure(name: string, startMark: string, endMark?: string): void {
    performance.measure(name, startMark, endMark);
  }
  
  private recordMetric(metric: PerformanceMetric): void {
    if (!this.metrics.has(metric.name)) {
      this.metrics.set(metric.name, []);
    }
    this.metrics.get(metric.name)!.push(metric);
  }
  
  getMetrics(name?: string): PerformanceMetric[] {
    if (name) {
      return this.metrics.get(name) || [];
    }
    return Array.from(this.metrics.values()).flat();
  }
  
  getAverageMetric(name: string): number {
    const metrics = this.metrics.get(name) || [];
    if (metrics.length === 0) return 0;
    
    const total = metrics.reduce((sum, metric) => sum + metric.duration, 0);
    return total / metrics.length;
  }
  
  dispose(): void {
    this.observer.disconnect();
    this.metrics.clear();
  }
}

interface PerformanceMetric {
  name: string;
  duration: number;
  startTime: number;
  type: string;
  timestamp: string;
}

// 全局性能监控实例
export const performanceMonitor = new PerformanceMonitor();

// 使用示例
export function withPerformanceTracking<T extends (...args: any[]) => any>(
  fn: T,
  name: string
): T {
  return ((...args: any[]) => {
    const startMark = `${name}-start`;
    const endMark = `${name}-end`;
    
    performanceMonitor.mark(startMark);
    
    const result = fn(...args);
    
    if (result instanceof Promise) {
      return result.finally(() => {
        performanceMonitor.mark(endMark);
        performanceMonitor.measure(name, startMark, endMark);
      });
    } else {
      performanceMonitor.mark(endMark);
      performanceMonitor.measure(name, startMark, endMark);
      return result;
    }
  }) as T;
}
```

---

## 🚀 生产环境最佳实践

### 监控和可观测性

#### 1. 结构化日志
```typescript
// src/utils/structured-logger.ts
import winston from 'winston';

interface LogContext {
  requestId?: string;
  userId?: string;
  protocolId?: string;
  sessionId?: string;
  traceId?: string;
  [key: string]: any;
}

class StructuredLogger {
  private logger: winston.Logger;
  
  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json(),
        winston.format.printf(({ timestamp, level, message, ...meta }) => {
          return JSON.stringify({
            timestamp,
            level,
            message,
            ...meta,
            service: 'mplp-v1',
            version: process.env.APP_VERSION || '1.0.0',
            environment: process.env.NODE_ENV || 'development'
          });
        })
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ 
          filename: 'logs/error.log', 
          level: 'error' 
        }),
        new winston.transports.File({ 
          filename: 'logs/combined.log' 
        })
      ]
    });
  }
  
  info(message: string, context?: LogContext): void {
    this.logger.info(message, context);
  }
  
  error(message: string, error?: Error, context?: LogContext): void {
    this.logger.error(message, {
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      ...context
    });
  }
  
  warn(message: string, context?: LogContext): void {
    this.logger.warn(message, context);
  }
  
  debug(message: string, context?: LogContext): void {
    this.logger.debug(message, context);
  }
}

export const logger = new StructuredLogger();
```

#### 2. 健康检查和指标
```typescript
// src/utils/health-check.ts
interface HealthCheckResult {
  status: 'healthy' | 'unhealthy' | 'degraded';
  checks: Record<string, {
    status: 'pass' | 'fail' | 'warn';
    message?: string;
    duration?: number;
  }>;
  timestamp: string;
  uptime: number;
  version: string;
}

class HealthChecker {
  private checks: Map<string, () => Promise<{ status: 'pass' | 'fail' | 'warn'; message?: string }>> = new Map();
  
  addCheck(name: string, check: () => Promise<{ status: 'pass' | 'fail' | 'warn'; message?: string }>): void {
    this.checks.set(name, check);
  }
  
  async runChecks(): Promise<HealthCheckResult> {
    const results: Record<string, any> = {};
    let overallStatus: 'healthy' | 'unhealthy' | 'degraded' = 'healthy';
    
    for (const [name, check] of this.checks) {
      const startTime = Date.now();
      try {
        const result = await Promise.race([
          check(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Health check timeout')), 5000)
          )
        ]) as { status: 'pass' | 'fail' | 'warn'; message?: string };
        
        results[name] = {
          ...result,
          duration: Date.now() - startTime
        };
        
        if (result.status === 'fail') {
          overallStatus = 'unhealthy';
        } else if (result.status === 'warn' && overallStatus === 'healthy') {
          overallStatus = 'degraded';
        }
      } catch (error) {
        results[name] = {
          status: 'fail',
          message: error instanceof Error ? error.message : 'Unknown error',
          duration: Date.now() - startTime
        };
        overallStatus = 'unhealthy';
      }
    }
    
    return {
      status: overallStatus,
      checks: results,
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      version: process.env.APP_VERSION || '1.0.0'
    };
  }
}

// 预定义健康检查
export const healthChecker = new HealthChecker();

// 数据库连接检查
healthChecker.addCheck('database', async () => {
  try {
    await database.raw('SELECT 1');
    return { status: 'pass' };
  } catch (error) {
    return { 
      status: 'fail', 
      message: `Database connection failed: ${error.message}` 
    };
  }
});

// Redis连接检查
healthChecker.addCheck('redis', async () => {
  try {
    await redis.ping();
    return { status: 'pass' };
  } catch (error) {
    return { 
      status: 'fail', 
      message: `Redis connection failed: ${error.message}` 
    };
  }
});

// 内存使用检查
healthChecker.addCheck('memory', async () => {
  const usage = process.memoryUsage();
  const heapUsedMB = usage.heapUsed / 1024 / 1024;
  const heapTotalMB = usage.heapTotal / 1024 / 1024;
  const usagePercent = (heapUsedMB / heapTotalMB) * 100;
  
  if (usagePercent > 90) {
    return { 
      status: 'fail', 
      message: `High memory usage: ${usagePercent.toFixed(2)}%` 
    };
  } else if (usagePercent > 75) {
    return { 
      status: 'warn', 
      message: `Elevated memory usage: ${usagePercent.toFixed(2)}%` 
    };
  }
  
  return { status: 'pass' };
});
```

#### 3. 分布式追踪
```typescript
// src/utils/tracing.ts
import { v4 as uuidv4 } from 'uuid';

interface TraceContext {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  baggage?: Record<string, string>;
}

class TracingManager {
  private static instance: TracingManager;
  private activeSpans: Map<string, TraceSpan> = new Map();
  
  static getInstance(): TracingManager {
    if (!TracingManager.instance) {
      TracingManager.instance = new TracingManager();
    }
    return TracingManager.instance;
  }
  
  startSpan(operationName: string, parentContext?: TraceContext): TraceSpan {
    const span = new TraceSpan({
      traceId: parentContext?.traceId || uuidv4(),
      spanId: uuidv4(),
      parentSpanId: parentContext?.spanId,
      operationName,
      startTime: Date.now(),
      baggage: parentContext?.baggage || {}
    });
    
    this.activeSpans.set(span.spanId, span);
    return span;
  }
  
  finishSpan(spanId: string): void {
    const span = this.activeSpans.get(spanId);
    if (span) {
      span.finish();
      this.activeSpans.delete(spanId);
      
      // 发送到追踪系统 (Jaeger, Zipkin等)
      this.exportSpan(span);
    }
  }
  
  private exportSpan(span: TraceSpan): void {
    // 实现追踪数据导出逻辑
    logger.debug('Span finished', {
      traceId: span.traceId,
      spanId: span.spanId,
      operationName: span.operationName,
      duration: span.duration,
      tags: span.tags
    });
  }
}

class TraceSpan {
  public readonly traceId: string;
  public readonly spanId: string;
  public readonly parentSpanId?: string;
  public readonly operationName: string;
  public readonly startTime: number;
  public readonly baggage: Record<string, string>;
  public tags: Record<string, any> = {};
  public logs: Array<{ timestamp: number; fields: Record<string, any> }> = [];
  private endTime?: number;
  
  constructor(config: {
    traceId: string;
    spanId: string;
    parentSpanId?: string;
    operationName: string;
    startTime: number;
    baggage: Record<string, string>;
  }) {
    Object.assign(this, config);
  }
  
  setTag(key: string, value: any): this {
    this.tags[key] = value;
    return this;
  }
  
  log(fields: Record<string, any>): this {
    this.logs.push({
      timestamp: Date.now(),
      fields
    });
    return this;
  }
  
  finish(): void {
    this.endTime = Date.now();
  }
  
  get duration(): number {
    return (this.endTime || Date.now()) - this.startTime;
  }
  
  getContext(): TraceContext {
    return {
      traceId: this.traceId,
      spanId: this.spanId,
      parentSpanId: this.parentSpanId,
      baggage: this.baggage
    };
  }
}

// 追踪装饰器
export function Traced(operationName?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    const opName = operationName || `${target.constructor.name}.${propertyName}`;
    
    descriptor.value = async function (...args: any[]) {
      const tracer = TracingManager.getInstance();
      const span = tracer.startSpan(opName);
      
      try {
        span.setTag('method', propertyName)
             .setTag('class', target.constructor.name);
        
        const result = await method.apply(this, args);
        
        span.setTag('success', true);
        return result;
      } catch (error) {
        span.setTag('success', false)
             .setTag('error', true)
             .log({ error: error.message });
        throw error;
      } finally {
        tracer.finishSpan(span.spanId);
      }
    };
  };
}

export const tracer = TracingManager.getInstance();
```

---

*本文档将随着项目进展持续更新，请确保使用最新版本。*